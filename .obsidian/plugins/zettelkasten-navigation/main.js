/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/svg-pan-zoom/src/uniwheel.js
var require_uniwheel = __commonJS({
  "node_modules/svg-pan-zoom/src/uniwheel.js"(exports, module2) {
    module2.exports = function() {
      var prefix = "", _addEventListener, _removeEventListener, support, fns = [];
      var passiveOption = { passive: true };
      if (window.addEventListener) {
        _addEventListener = "addEventListener";
        _removeEventListener = "removeEventListener";
      } else {
        _addEventListener = "attachEvent";
        _removeEventListener = "detachEvent";
        prefix = "on";
      }
      support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
      function createCallback(element, callback) {
        var fn = function(originalEvent) {
          !originalEvent && (originalEvent = window.event);
          var event = {
            originalEvent,
            target: originalEvent.target || originalEvent.srcElement,
            type: "wheel",
            deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
            deltaX: 0,
            delatZ: 0,
            preventDefault: function() {
              originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
            }
          };
          if (support == "mousewheel") {
            event.deltaY = -1 / 40 * originalEvent.wheelDelta;
            originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);
          } else {
            event.deltaY = originalEvent.detail;
          }
          return callback(event);
        };
        fns.push({
          element,
          fn
        });
        return fn;
      }
      function getCallback(element) {
        for (var i = 0; i < fns.length; i++) {
          if (fns[i].element === element) {
            return fns[i].fn;
          }
        }
        return function() {
        };
      }
      function removeCallback(element) {
        for (var i = 0; i < fns.length; i++) {
          if (fns[i].element === element) {
            return fns.splice(i, 1);
          }
        }
      }
      function _addWheelListener(elem, eventName, callback, isPassiveListener) {
        var cb;
        if (support === "wheel") {
          cb = callback;
        } else {
          cb = createCallback(elem, callback);
        }
        elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);
      }
      function _removeWheelListener(elem, eventName, callback, isPassiveListener) {
        var cb;
        if (support === "wheel") {
          cb = callback;
        } else {
          cb = getCallback(elem);
        }
        elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveOption : false);
        removeCallback(elem);
      }
      function addWheelListener(elem, callback, isPassiveListener) {
        _addWheelListener(elem, support, callback, isPassiveListener);
        if (support == "DOMMouseScroll") {
          _addWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
        }
      }
      function removeWheelListener(elem, callback, isPassiveListener) {
        _removeWheelListener(elem, support, callback, isPassiveListener);
        if (support == "DOMMouseScroll") {
          _removeWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
        }
      }
      return {
        on: addWheelListener,
        off: removeWheelListener
      };
    }();
  }
});

// node_modules/svg-pan-zoom/src/utilities.js
var require_utilities = __commonJS({
  "node_modules/svg-pan-zoom/src/utilities.js"(exports, module2) {
    module2.exports = {
      extend: function(target, source) {
        target = target || {};
        for (var prop in source) {
          if (this.isObject(source[prop])) {
            target[prop] = this.extend(target[prop], source[prop]);
          } else {
            target[prop] = source[prop];
          }
        }
        return target;
      },
      isElement: function(o) {
        return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
      },
      isObject: function(o) {
        return Object.prototype.toString.call(o) === "[object Object]";
      },
      isNumber: function(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
      },
      getSvg: function(elementOrSelector) {
        var element, svg;
        if (!this.isElement(elementOrSelector)) {
          if (typeof elementOrSelector === "string" || elementOrSelector instanceof String) {
            element = document.querySelector(elementOrSelector);
            if (!element) {
              throw new Error("Provided selector did not find any elements. Selector: " + elementOrSelector);
              return null;
            }
          } else {
            throw new Error("Provided selector is not an HTML object nor String");
            return null;
          }
        } else {
          element = elementOrSelector;
        }
        if (element.tagName.toLowerCase() === "svg") {
          svg = element;
        } else {
          if (element.tagName.toLowerCase() === "object") {
            svg = element.contentDocument.documentElement;
          } else {
            if (element.tagName.toLowerCase() === "embed") {
              svg = element.getSVGDocument().documentElement;
            } else {
              if (element.tagName.toLowerCase() === "img") {
                throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
              } else {
                throw new Error("Cannot get SVG.");
              }
              return null;
            }
          }
        }
        return svg;
      },
      proxy: function(fn, context) {
        return function() {
          return fn.apply(context, arguments);
        };
      },
      getType: function(o) {
        return Object.prototype.toString.apply(o).replace(/^\[object\s/, "").replace(/\]$/, "");
      },
      mouseAndTouchNormalize: function(evt, svg) {
        if (evt.clientX === void 0 || evt.clientX === null) {
          evt.clientX = 0;
          evt.clientY = 0;
          if (evt.touches !== void 0 && evt.touches.length) {
            if (evt.touches[0].clientX !== void 0) {
              evt.clientX = evt.touches[0].clientX;
              evt.clientY = evt.touches[0].clientY;
            } else if (evt.touches[0].pageX !== void 0) {
              var rect = svg.getBoundingClientRect();
              evt.clientX = evt.touches[0].pageX - rect.left;
              evt.clientY = evt.touches[0].pageY - rect.top;
            }
          } else if (evt.originalEvent !== void 0) {
            if (evt.originalEvent.clientX !== void 0) {
              evt.clientX = evt.originalEvent.clientX;
              evt.clientY = evt.originalEvent.clientY;
            }
          }
        }
      },
      isDblClick: function(evt, prevEvt) {
        if (evt.detail === 2) {
          return true;
        } else if (prevEvt !== void 0 && prevEvt !== null) {
          var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));
          return timeStampDiff < 250 && touchesDistance < 10;
        }
        return false;
      },
      now: Date.now || function() {
        return new Date().getTime();
      },
      throttle: function(func, wait, options) {
        var that = this;
        var context, args, result;
        var timeout = null;
        var previous = 0;
        if (!options) {
          options = {};
        }
        var later = function() {
          previous = options.leading === false ? 0 : that.now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) {
            context = args = null;
          }
        };
        return function() {
          var now = that.now();
          if (!previous && options.leading === false) {
            previous = now;
          }
          var remaining = wait - (now - previous);
          context = this;
          args = arguments;
          if (remaining <= 0 || remaining > wait) {
            clearTimeout(timeout);
            timeout = null;
            previous = now;
            result = func.apply(context, args);
            if (!timeout) {
              context = args = null;
            }
          } else if (!timeout && options.trailing !== false) {
            timeout = setTimeout(later, remaining);
          }
          return result;
        };
      },
      createRequestAnimationFrame: function(refreshRate) {
        var timeout = null;
        if (refreshRate !== "auto" && refreshRate < 60 && refreshRate > 1) {
          timeout = Math.floor(1e3 / refreshRate);
        }
        if (timeout === null) {
          return window.requestAnimationFrame || requestTimeout(33);
        } else {
          return requestTimeout(timeout);
        }
      }
    };
    function requestTimeout(timeout) {
      return function(callback) {
        window.setTimeout(callback, timeout);
      };
    }
  }
});

// node_modules/svg-pan-zoom/src/svg-utilities.js
var require_svg_utilities = __commonJS({
  "node_modules/svg-pan-zoom/src/svg-utilities.js"(exports, module2) {
    var Utils = require_utilities();
    var _browser = "unknown";
    if (!!document.documentMode) {
      _browser = "ie";
    }
    module2.exports = {
      svgNS: "http://www.w3.org/2000/svg",
      xmlNS: "http://www.w3.org/XML/1998/namespace",
      xmlnsNS: "http://www.w3.org/2000/xmlns/",
      xlinkNS: "http://www.w3.org/1999/xlink",
      evNS: "http://www.w3.org/2001/xml-events",
      getBoundingClientRectNormalized: function(svg) {
        if (svg.clientWidth && svg.clientHeight) {
          return { width: svg.clientWidth, height: svg.clientHeight };
        } else if (!!svg.getBoundingClientRect()) {
          return svg.getBoundingClientRect();
        } else {
          throw new Error("Cannot get BoundingClientRect for SVG.");
        }
      },
      getOrCreateViewport: function(svg, selector) {
        var viewport = null;
        if (Utils.isElement(selector)) {
          viewport = selector;
        } else {
          viewport = svg.querySelector(selector);
        }
        if (!viewport) {
          var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el) {
            return el.nodeName !== "defs" && el.nodeName !== "#text";
          });
          if (childNodes.length === 1 && childNodes[0].nodeName === "g" && childNodes[0].getAttribute("transform") === null) {
            viewport = childNodes[0];
          }
        }
        if (!viewport) {
          var viewportId = "viewport-" + new Date().toISOString().replace(/\D/g, "");
          viewport = document.createElementNS(this.svgNS, "g");
          viewport.setAttribute("id", viewportId);
          var svgChildren = svg.childNodes || svg.children;
          if (!!svgChildren && svgChildren.length > 0) {
            for (var i = svgChildren.length; i > 0; i--) {
              if (svgChildren[svgChildren.length - i].nodeName !== "defs") {
                viewport.appendChild(svgChildren[svgChildren.length - i]);
              }
            }
          }
          svg.appendChild(viewport);
        }
        var classNames = [];
        if (viewport.getAttribute("class")) {
          classNames = viewport.getAttribute("class").split(" ");
        }
        if (!~classNames.indexOf("svg-pan-zoom_viewport")) {
          classNames.push("svg-pan-zoom_viewport");
          viewport.setAttribute("class", classNames.join(" "));
        }
        return viewport;
      },
      setupSvgAttributes: function(svg) {
        svg.setAttribute("xmlns", this.svgNS);
        svg.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS);
        svg.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS);
        if (svg.parentNode !== null) {
          var style = svg.getAttribute("style") || "";
          if (style.toLowerCase().indexOf("overflow") === -1) {
            svg.setAttribute("style", "overflow: hidden; " + style);
          }
        }
      },
      internetExplorerRedisplayInterval: 300,
      refreshDefsGlobal: Utils.throttle(function() {
        var allDefs = document.querySelectorAll("defs");
        var allDefsCount = allDefs.length;
        for (var i = 0; i < allDefsCount; i++) {
          var thisDefs = allDefs[i];
          thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
        }
      }, exports ? exports.internetExplorerRedisplayInterval : null),
      setCTM: function(element, matrix, defs) {
        var that = this, s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
        element.setAttributeNS(null, "transform", s);
        if ("transform" in element.style) {
          element.style.transform = s;
        } else if ("-ms-transform" in element.style) {
          element.style["-ms-transform"] = s;
        } else if ("-webkit-transform" in element.style) {
          element.style["-webkit-transform"] = s;
        }
        if (_browser === "ie" && !!defs) {
          defs.parentNode.insertBefore(defs, defs);
          window.setTimeout(function() {
            that.refreshDefsGlobal();
          }, that.internetExplorerRedisplayInterval);
        }
      },
      getEventPoint: function(evt, svg) {
        var point = svg.createSVGPoint();
        Utils.mouseAndTouchNormalize(evt, svg);
        point.x = evt.clientX;
        point.y = evt.clientY;
        return point;
      },
      getSvgCenterPoint: function(svg, width, height) {
        return this.createSVGPoint(svg, width / 2, height / 2);
      },
      createSVGPoint: function(svg, x, y) {
        var point = svg.createSVGPoint();
        point.x = x;
        point.y = y;
        return point;
      }
    };
  }
});

// node_modules/svg-pan-zoom/src/control-icons.js
var require_control_icons = __commonJS({
  "node_modules/svg-pan-zoom/src/control-icons.js"(exports, module2) {
    var SvgUtils = require_svg_utilities();
    module2.exports = {
      enable: function(instance) {
        var defs = instance.svg.querySelector("defs");
        if (!defs) {
          defs = document.createElementNS(SvgUtils.svgNS, "defs");
          instance.svg.appendChild(defs);
        }
        var styleEl = defs.querySelector("style#svg-pan-zoom-controls-styles");
        if (!styleEl) {
          var style = document.createElementNS(SvgUtils.svgNS, "style");
          style.setAttribute("id", "svg-pan-zoom-controls-styles");
          style.setAttribute("type", "text/css");
          style.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }";
          defs.appendChild(style);
        }
        var zoomGroup = document.createElementNS(SvgUtils.svgNS, "g");
        zoomGroup.setAttribute("id", "svg-pan-zoom-controls");
        zoomGroup.setAttribute("transform", "translate(" + (instance.width - 70) + " " + (instance.height - 76) + ") scale(0.75)");
        zoomGroup.setAttribute("class", "svg-pan-zoom-control");
        zoomGroup.appendChild(this._createZoomIn(instance));
        zoomGroup.appendChild(this._createZoomReset(instance));
        zoomGroup.appendChild(this._createZoomOut(instance));
        instance.svg.appendChild(zoomGroup);
        instance.controlIcons = zoomGroup;
      },
      _createZoomIn: function(instance) {
        var zoomIn = document.createElementNS(SvgUtils.svgNS, "g");
        zoomIn.setAttribute("id", "svg-pan-zoom-zoom-in");
        zoomIn.setAttribute("transform", "translate(30.5 5) scale(0.015)");
        zoomIn.setAttribute("class", "svg-pan-zoom-control");
        zoomIn.addEventListener("click", function() {
          instance.getPublicInstance().zoomIn();
        }, false);
        zoomIn.addEventListener("touchstart", function() {
          instance.getPublicInstance().zoomIn();
        }, false);
        var zoomInBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        zoomInBackground.setAttribute("x", "0");
        zoomInBackground.setAttribute("y", "0");
        zoomInBackground.setAttribute("width", "1500");
        zoomInBackground.setAttribute("height", "1400");
        zoomInBackground.setAttribute("class", "svg-pan-zoom-control-background");
        zoomIn.appendChild(zoomInBackground);
        var zoomInShape = document.createElementNS(SvgUtils.svgNS, "path");
        zoomInShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z");
        zoomInShape.setAttribute("class", "svg-pan-zoom-control-element");
        zoomIn.appendChild(zoomInShape);
        return zoomIn;
      },
      _createZoomReset: function(instance) {
        var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, "g");
        resetPanZoomControl.setAttribute("id", "svg-pan-zoom-reset-pan-zoom");
        resetPanZoomControl.setAttribute("transform", "translate(5 35) scale(0.4)");
        resetPanZoomControl.setAttribute("class", "svg-pan-zoom-control");
        resetPanZoomControl.addEventListener("click", function() {
          instance.getPublicInstance().reset();
        }, false);
        resetPanZoomControl.addEventListener("touchstart", function() {
          instance.getPublicInstance().reset();
        }, false);
        var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        resetPanZoomControlBackground.setAttribute("x", "2");
        resetPanZoomControlBackground.setAttribute("y", "2");
        resetPanZoomControlBackground.setAttribute("width", "182");
        resetPanZoomControlBackground.setAttribute("height", "58");
        resetPanZoomControlBackground.setAttribute("class", "svg-pan-zoom-control-background");
        resetPanZoomControl.appendChild(resetPanZoomControlBackground);
        var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, "path");
        resetPanZoomControlShape1.setAttribute("d", "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z");
        resetPanZoomControlShape1.setAttribute("class", "svg-pan-zoom-control-element");
        resetPanZoomControl.appendChild(resetPanZoomControlShape1);
        var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, "path");
        resetPanZoomControlShape2.setAttribute("d", "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z");
        resetPanZoomControlShape2.setAttribute("class", "svg-pan-zoom-control-element");
        resetPanZoomControl.appendChild(resetPanZoomControlShape2);
        return resetPanZoomControl;
      },
      _createZoomOut: function(instance) {
        var zoomOut = document.createElementNS(SvgUtils.svgNS, "g");
        zoomOut.setAttribute("id", "svg-pan-zoom-zoom-out");
        zoomOut.setAttribute("transform", "translate(30.5 70) scale(0.015)");
        zoomOut.setAttribute("class", "svg-pan-zoom-control");
        zoomOut.addEventListener("click", function() {
          instance.getPublicInstance().zoomOut();
        }, false);
        zoomOut.addEventListener("touchstart", function() {
          instance.getPublicInstance().zoomOut();
        }, false);
        var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, "rect");
        zoomOutBackground.setAttribute("x", "0");
        zoomOutBackground.setAttribute("y", "0");
        zoomOutBackground.setAttribute("width", "1500");
        zoomOutBackground.setAttribute("height", "1400");
        zoomOutBackground.setAttribute("class", "svg-pan-zoom-control-background");
        zoomOut.appendChild(zoomOutBackground);
        var zoomOutShape = document.createElementNS(SvgUtils.svgNS, "path");
        zoomOutShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z");
        zoomOutShape.setAttribute("class", "svg-pan-zoom-control-element");
        zoomOut.appendChild(zoomOutShape);
        return zoomOut;
      },
      disable: function(instance) {
        if (instance.controlIcons) {
          instance.controlIcons.parentNode.removeChild(instance.controlIcons);
          instance.controlIcons = null;
        }
      }
    };
  }
});

// node_modules/svg-pan-zoom/src/shadow-viewport.js
var require_shadow_viewport = __commonJS({
  "node_modules/svg-pan-zoom/src/shadow-viewport.js"(exports, module2) {
    var SvgUtils = require_svg_utilities();
    var Utils = require_utilities();
    var ShadowViewport = function(viewport, options) {
      this.init(viewport, options);
    };
    ShadowViewport.prototype.init = function(viewport, options) {
      this.viewport = viewport;
      this.options = options;
      this.originalState = { zoom: 1, x: 0, y: 0 };
      this.activeState = { zoom: 1, x: 0, y: 0 };
      this.updateCTMCached = Utils.proxy(this.updateCTM, this);
      this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate);
      this.viewBox = { x: 0, y: 0, width: 0, height: 0 };
      this.cacheViewBox();
      var newCTM = this.processCTM();
      this.setCTM(newCTM);
      this.updateCTM();
    };
    ShadowViewport.prototype.cacheViewBox = function() {
      var svgViewBox = this.options.svg.getAttribute("viewBox");
      if (svgViewBox) {
        var viewBoxValues = svgViewBox.split(/[\s\,]/).filter(function(v) {
          return v;
        }).map(parseFloat);
        this.viewBox.x = viewBoxValues[0];
        this.viewBox.y = viewBoxValues[1];
        this.viewBox.width = viewBoxValues[2];
        this.viewBox.height = viewBoxValues[3];
        var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        this.activeState.zoom = zoom;
        this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;
        this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;
        this.updateCTMOnNextFrame();
        this.options.svg.removeAttribute("viewBox");
      } else {
        this.simpleViewBoxCache();
      }
    };
    ShadowViewport.prototype.simpleViewBoxCache = function() {
      var bBox = this.viewport.getBBox();
      this.viewBox.x = bBox.x;
      this.viewBox.y = bBox.y;
      this.viewBox.width = bBox.width;
      this.viewBox.height = bBox.height;
    };
    ShadowViewport.prototype.getViewBox = function() {
      return Utils.extend({}, this.viewBox);
    };
    ShadowViewport.prototype.processCTM = function() {
      var newCTM = this.getCTM();
      if (this.options.fit || this.options.contain) {
        var newScale;
        if (this.options.fit) {
          newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        } else {
          newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
        }
        newCTM.a = newScale;
        newCTM.d = newScale;
        newCTM.e = -this.viewBox.x * newScale;
        newCTM.f = -this.viewBox.y * newScale;
      }
      if (this.options.center) {
        var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5, offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;
        newCTM.e = offsetX;
        newCTM.f = offsetY;
      }
      this.originalState.zoom = newCTM.a;
      this.originalState.x = newCTM.e;
      this.originalState.y = newCTM.f;
      return newCTM;
    };
    ShadowViewport.prototype.getOriginalState = function() {
      return Utils.extend({}, this.originalState);
    };
    ShadowViewport.prototype.getState = function() {
      return Utils.extend({}, this.activeState);
    };
    ShadowViewport.prototype.getZoom = function() {
      return this.activeState.zoom;
    };
    ShadowViewport.prototype.getRelativeZoom = function() {
      return this.activeState.zoom / this.originalState.zoom;
    };
    ShadowViewport.prototype.computeRelativeZoom = function(scale) {
      return scale / this.originalState.zoom;
    };
    ShadowViewport.prototype.getPan = function() {
      return { x: this.activeState.x, y: this.activeState.y };
    };
    ShadowViewport.prototype.getCTM = function() {
      var safeCTM = this.options.svg.createSVGMatrix();
      safeCTM.a = this.activeState.zoom;
      safeCTM.b = 0;
      safeCTM.c = 0;
      safeCTM.d = this.activeState.zoom;
      safeCTM.e = this.activeState.x;
      safeCTM.f = this.activeState.y;
      return safeCTM;
    };
    ShadowViewport.prototype.setCTM = function(newCTM) {
      var willZoom = this.isZoomDifferent(newCTM), willPan = this.isPanDifferent(newCTM);
      if (willZoom || willPan) {
        if (willZoom) {
          if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
            newCTM.a = newCTM.d = this.activeState.zoom;
            willZoom = false;
          } else {
            this.updateCache(newCTM);
            this.options.onZoom(this.getRelativeZoom());
          }
        }
        if (willPan) {
          var preventPan = this.options.beforePan(this.getPan(), {
            x: newCTM.e,
            y: newCTM.f
          }), preventPanX = false, preventPanY = false;
          if (preventPan === false) {
            newCTM.e = this.getPan().x;
            newCTM.f = this.getPan().y;
            preventPanX = preventPanY = true;
          } else if (Utils.isObject(preventPan)) {
            if (preventPan.x === false) {
              newCTM.e = this.getPan().x;
              preventPanX = true;
            } else if (Utils.isNumber(preventPan.x)) {
              newCTM.e = preventPan.x;
            }
            if (preventPan.y === false) {
              newCTM.f = this.getPan().y;
              preventPanY = true;
            } else if (Utils.isNumber(preventPan.y)) {
              newCTM.f = preventPan.y;
            }
          }
          if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {
            willPan = false;
          } else {
            this.updateCache(newCTM);
            this.options.onPan(this.getPan());
          }
        }
        if (willZoom || willPan) {
          this.updateCTMOnNextFrame();
        }
      }
    };
    ShadowViewport.prototype.isZoomDifferent = function(newCTM) {
      return this.activeState.zoom !== newCTM.a;
    };
    ShadowViewport.prototype.isPanDifferent = function(newCTM) {
      return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;
    };
    ShadowViewport.prototype.updateCache = function(newCTM) {
      this.activeState.zoom = newCTM.a;
      this.activeState.x = newCTM.e;
      this.activeState.y = newCTM.f;
    };
    ShadowViewport.prototype.pendingUpdate = false;
    ShadowViewport.prototype.updateCTMOnNextFrame = function() {
      if (!this.pendingUpdate) {
        this.pendingUpdate = true;
        this.requestAnimationFrame.call(window, this.updateCTMCached);
      }
    };
    ShadowViewport.prototype.updateCTM = function() {
      var ctm = this.getCTM();
      SvgUtils.setCTM(this.viewport, ctm, this.defs);
      this.pendingUpdate = false;
      if (this.options.onUpdatedCTM) {
        this.options.onUpdatedCTM(ctm);
      }
    };
    module2.exports = function(viewport, options) {
      return new ShadowViewport(viewport, options);
    };
  }
});

// node_modules/svg-pan-zoom/src/svg-pan-zoom.js
var require_svg_pan_zoom = __commonJS({
  "node_modules/svg-pan-zoom/src/svg-pan-zoom.js"(exports, module2) {
    var Wheel = require_uniwheel();
    var ControlIcons = require_control_icons();
    var Utils = require_utilities();
    var SvgUtils = require_svg_utilities();
    var ShadowViewport = require_shadow_viewport();
    var SvgPanZoom = function(svg, options) {
      this.init(svg, options);
    };
    var optionsDefaults = {
      viewportSelector: ".svg-pan-zoom_viewport",
      panEnabled: true,
      controlIconsEnabled: false,
      zoomEnabled: true,
      dblClickZoomEnabled: true,
      mouseWheelZoomEnabled: true,
      preventMouseEventsDefault: true,
      zoomScaleSensitivity: 0.1,
      minZoom: 0.5,
      maxZoom: 10,
      fit: true,
      contain: false,
      center: true,
      refreshRate: "auto",
      beforeZoom: null,
      onZoom: null,
      beforePan: null,
      onPan: null,
      customEventsHandler: null,
      eventsListenerElement: null,
      onUpdatedCTM: null
    };
    var passiveListenerOption = { passive: true };
    SvgPanZoom.prototype.init = function(svg, options) {
      var that = this;
      this.svg = svg;
      this.defs = svg.querySelector("defs");
      SvgUtils.setupSvgAttributes(this.svg);
      this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);
      this.state = "none";
      var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);
      this.width = boundingClientRectNormalized.width;
      this.height = boundingClientRectNormalized.height;
      this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
        svg: this.svg,
        width: this.width,
        height: this.height,
        fit: this.options.fit,
        contain: this.options.contain,
        center: this.options.center,
        refreshRate: this.options.refreshRate,
        beforeZoom: function(oldScale, newScale) {
          if (that.viewport && that.options.beforeZoom) {
            return that.options.beforeZoom(oldScale, newScale);
          }
        },
        onZoom: function(scale) {
          if (that.viewport && that.options.onZoom) {
            return that.options.onZoom(scale);
          }
        },
        beforePan: function(oldPoint, newPoint) {
          if (that.viewport && that.options.beforePan) {
            return that.options.beforePan(oldPoint, newPoint);
          }
        },
        onPan: function(point) {
          if (that.viewport && that.options.onPan) {
            return that.options.onPan(point);
          }
        },
        onUpdatedCTM: function(ctm) {
          if (that.viewport && that.options.onUpdatedCTM) {
            return that.options.onUpdatedCTM(ctm);
          }
        }
      });
      var publicInstance = this.getPublicInstance();
      publicInstance.setBeforeZoom(this.options.beforeZoom);
      publicInstance.setOnZoom(this.options.onZoom);
      publicInstance.setBeforePan(this.options.beforePan);
      publicInstance.setOnPan(this.options.onPan);
      publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);
      if (this.options.controlIconsEnabled) {
        ControlIcons.enable(this);
      }
      this.lastMouseWheelEventTime = Date.now();
      this.setupHandlers();
    };
    SvgPanZoom.prototype.setupHandlers = function() {
      var that = this, prevEvt = null;
      this.eventListeners = {
        mousedown: function(evt) {
          var result = that.handleMouseDown(evt, prevEvt);
          prevEvt = evt;
          return result;
        },
        touchstart: function(evt) {
          var result = that.handleMouseDown(evt, prevEvt);
          prevEvt = evt;
          return result;
        },
        mouseup: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchend: function(evt) {
          return that.handleMouseUp(evt);
        },
        mousemove: function(evt) {
          return that.handleMouseMove(evt);
        },
        touchmove: function(evt) {
          return that.handleMouseMove(evt);
        },
        mouseleave: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchleave: function(evt) {
          return that.handleMouseUp(evt);
        },
        touchcancel: function(evt) {
          return that.handleMouseUp(evt);
        }
      };
      if (this.options.customEventsHandler != null) {
        this.options.customEventsHandler.init({
          svgElement: this.svg,
          eventsListenerElement: this.options.eventsListenerElement,
          instance: this.getPublicInstance()
        });
        var haltEventListeners = this.options.customEventsHandler.haltEventListeners;
        if (haltEventListeners && haltEventListeners.length) {
          for (var i = haltEventListeners.length - 1; i >= 0; i--) {
            if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
              delete this.eventListeners[haltEventListeners[i]];
            }
          }
        }
      }
      for (var event in this.eventListeners) {
        (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);
      }
      if (this.options.mouseWheelZoomEnabled) {
        this.options.mouseWheelZoomEnabled = false;
        this.enableMouseWheelZoom();
      }
    };
    SvgPanZoom.prototype.enableMouseWheelZoom = function() {
      if (!this.options.mouseWheelZoomEnabled) {
        var that = this;
        this.wheelListener = function(evt) {
          return that.handleMouseWheel(evt);
        };
        var isPassiveListener = !this.options.preventMouseEventsDefault;
        Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
        this.options.mouseWheelZoomEnabled = true;
      }
    };
    SvgPanZoom.prototype.disableMouseWheelZoom = function() {
      if (this.options.mouseWheelZoomEnabled) {
        var isPassiveListener = !this.options.preventMouseEventsDefault;
        Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
        this.options.mouseWheelZoomEnabled = false;
      }
    };
    SvgPanZoom.prototype.handleMouseWheel = function(evt) {
      if (!this.options.zoomEnabled || this.state !== "none") {
        return;
      }
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      var delta = evt.deltaY || 1, timeDelta = Date.now() - this.lastMouseWheelEventTime, divider = 3 + Math.max(0, 30 - timeDelta);
      this.lastMouseWheelEventTime = Date.now();
      if ("deltaMode" in evt && evt.deltaMode === 0 && evt.wheelDelta) {
        delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;
      }
      delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;
      var inversedScreenCTM = this.svg.getScreenCTM().inverse(), relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM), zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);
      this.zoomAtPoint(zoom, relativeMousePoint);
    };
    SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
      var originalState = this.viewport.getOriginalState();
      if (!zoomAbsolute) {
        if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
          zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();
        } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
          zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();
        }
      } else {
        zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));
        zoomScale = zoomScale / this.getZoom();
      }
      var oldCTM = this.viewport.getCTM(), relativePoint = point.matrixTransform(oldCTM.inverse()), modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y), newCTM = oldCTM.multiply(modifier);
      if (newCTM.a !== oldCTM.a) {
        this.viewport.setCTM(newCTM);
      }
    };
    SvgPanZoom.prototype.zoom = function(scale, absolute) {
      this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);
    };
    SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
      if (absolute) {
        scale = this.computeFromRelativeZoom(scale);
      }
      this.zoom(scale, absolute);
    };
    SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
      if (absolute) {
        scale = this.computeFromRelativeZoom(scale);
      }
      if (Utils.getType(point) !== "SVGPoint") {
        if ("x" in point && "y" in point) {
          point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);
        } else {
          throw new Error("Given point is invalid");
        }
      }
      this.zoomAtPoint(scale, point, absolute);
    };
    SvgPanZoom.prototype.getZoom = function() {
      return this.viewport.getZoom();
    };
    SvgPanZoom.prototype.getRelativeZoom = function() {
      return this.viewport.getRelativeZoom();
    };
    SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
      return zoom * this.viewport.getOriginalState().zoom;
    };
    SvgPanZoom.prototype.resetZoom = function() {
      var originalState = this.viewport.getOriginalState();
      this.zoom(originalState.zoom, true);
    };
    SvgPanZoom.prototype.resetPan = function() {
      this.pan(this.viewport.getOriginalState());
    };
    SvgPanZoom.prototype.reset = function() {
      this.resetZoom();
      this.resetPan();
    };
    SvgPanZoom.prototype.handleDblClick = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.options.controlIconsEnabled) {
        var targetClass = evt.target.getAttribute("class") || "";
        if (targetClass.indexOf("svg-pan-zoom-control") > -1) {
          return false;
        }
      }
      var zoomFactor;
      if (evt.shiftKey) {
        zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);
      } else {
        zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;
      }
      var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());
      this.zoomAtPoint(zoomFactor, point);
    };
    SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      Utils.mouseAndTouchNormalize(evt, this.svg);
      if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {
        this.handleDblClick(evt);
      } else {
        this.state = "pan";
        this.firstEventCTM = this.viewport.getCTM();
        this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
      }
    };
    SvgPanZoom.prototype.handleMouseMove = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.state === "pan" && this.options.panEnabled) {
        var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()), viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
        this.viewport.setCTM(viewportCTM);
      }
    };
    SvgPanZoom.prototype.handleMouseUp = function(evt) {
      if (this.options.preventMouseEventsDefault) {
        if (evt.preventDefault) {
          evt.preventDefault();
        } else {
          evt.returnValue = false;
        }
      }
      if (this.state === "pan") {
        this.state = "none";
      }
    };
    SvgPanZoom.prototype.fit = function() {
      var viewBox = this.viewport.getViewBox(), newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);
      this.zoom(newScale, true);
    };
    SvgPanZoom.prototype.contain = function() {
      var viewBox = this.viewport.getViewBox(), newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);
      this.zoom(newScale, true);
    };
    SvgPanZoom.prototype.center = function() {
      var viewBox = this.viewport.getViewBox(), offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5, offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;
      this.getPublicInstance().pan({ x: offsetX, y: offsetY });
    };
    SvgPanZoom.prototype.updateBBox = function() {
      this.viewport.simpleViewBoxCache();
    };
    SvgPanZoom.prototype.pan = function(point) {
      var viewportCTM = this.viewport.getCTM();
      viewportCTM.e = point.x;
      viewportCTM.f = point.y;
      this.viewport.setCTM(viewportCTM);
    };
    SvgPanZoom.prototype.panBy = function(point) {
      var viewportCTM = this.viewport.getCTM();
      viewportCTM.e += point.x;
      viewportCTM.f += point.y;
      this.viewport.setCTM(viewportCTM);
    };
    SvgPanZoom.prototype.getPan = function() {
      var state = this.viewport.getState();
      return { x: state.x, y: state.y };
    };
    SvgPanZoom.prototype.resize = function() {
      var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);
      this.width = boundingClientRectNormalized.width;
      this.height = boundingClientRectNormalized.height;
      var viewport = this.viewport;
      viewport.options.width = this.width;
      viewport.options.height = this.height;
      viewport.processCTM();
      if (this.options.controlIconsEnabled) {
        this.getPublicInstance().disableControlIcons();
        this.getPublicInstance().enableControlIcons();
      }
    };
    SvgPanZoom.prototype.destroy = function() {
      var that = this;
      this.beforeZoom = null;
      this.onZoom = null;
      this.beforePan = null;
      this.onPan = null;
      this.onUpdatedCTM = null;
      if (this.options.customEventsHandler != null) {
        this.options.customEventsHandler.destroy({
          svgElement: this.svg,
          eventsListenerElement: this.options.eventsListenerElement,
          instance: this.getPublicInstance()
        });
      }
      for (var event in this.eventListeners) {
        (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerOption : false);
      }
      this.disableMouseWheelZoom();
      this.getPublicInstance().disableControlIcons();
      this.reset();
      instancesStore = instancesStore.filter(function(instance) {
        return instance.svg !== that.svg;
      });
      delete this.options;
      delete this.viewport;
      delete this.publicInstance;
      delete this.pi;
      this.getPublicInstance = function() {
        return null;
      };
    };
    SvgPanZoom.prototype.getPublicInstance = function() {
      var that = this;
      if (!this.publicInstance) {
        this.publicInstance = this.pi = {
          enablePan: function() {
            that.options.panEnabled = true;
            return that.pi;
          },
          disablePan: function() {
            that.options.panEnabled = false;
            return that.pi;
          },
          isPanEnabled: function() {
            return !!that.options.panEnabled;
          },
          pan: function(point) {
            that.pan(point);
            return that.pi;
          },
          panBy: function(point) {
            that.panBy(point);
            return that.pi;
          },
          getPan: function() {
            return that.getPan();
          },
          setBeforePan: function(fn) {
            that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          setOnPan: function(fn) {
            that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          enableZoom: function() {
            that.options.zoomEnabled = true;
            return that.pi;
          },
          disableZoom: function() {
            that.options.zoomEnabled = false;
            return that.pi;
          },
          isZoomEnabled: function() {
            return !!that.options.zoomEnabled;
          },
          enableControlIcons: function() {
            if (!that.options.controlIconsEnabled) {
              that.options.controlIconsEnabled = true;
              ControlIcons.enable(that);
            }
            return that.pi;
          },
          disableControlIcons: function() {
            if (that.options.controlIconsEnabled) {
              that.options.controlIconsEnabled = false;
              ControlIcons.disable(that);
            }
            return that.pi;
          },
          isControlIconsEnabled: function() {
            return !!that.options.controlIconsEnabled;
          },
          enableDblClickZoom: function() {
            that.options.dblClickZoomEnabled = true;
            return that.pi;
          },
          disableDblClickZoom: function() {
            that.options.dblClickZoomEnabled = false;
            return that.pi;
          },
          isDblClickZoomEnabled: function() {
            return !!that.options.dblClickZoomEnabled;
          },
          enableMouseWheelZoom: function() {
            that.enableMouseWheelZoom();
            return that.pi;
          },
          disableMouseWheelZoom: function() {
            that.disableMouseWheelZoom();
            return that.pi;
          },
          isMouseWheelZoomEnabled: function() {
            return !!that.options.mouseWheelZoomEnabled;
          },
          setZoomScaleSensitivity: function(scale) {
            that.options.zoomScaleSensitivity = scale;
            return that.pi;
          },
          setMinZoom: function(zoom) {
            that.options.minZoom = zoom;
            return that.pi;
          },
          setMaxZoom: function(zoom) {
            that.options.maxZoom = zoom;
            return that.pi;
          },
          setBeforeZoom: function(fn) {
            that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          setOnZoom: function(fn) {
            that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          zoom: function(scale) {
            that.publicZoom(scale, true);
            return that.pi;
          },
          zoomBy: function(scale) {
            that.publicZoom(scale, false);
            return that.pi;
          },
          zoomAtPoint: function(scale, point) {
            that.publicZoomAtPoint(scale, point, true);
            return that.pi;
          },
          zoomAtPointBy: function(scale, point) {
            that.publicZoomAtPoint(scale, point, false);
            return that.pi;
          },
          zoomIn: function() {
            this.zoomBy(1 + that.options.zoomScaleSensitivity);
            return that.pi;
          },
          zoomOut: function() {
            this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));
            return that.pi;
          },
          getZoom: function() {
            return that.getRelativeZoom();
          },
          setOnUpdatedCTM: function(fn) {
            that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);
            return that.pi;
          },
          resetZoom: function() {
            that.resetZoom();
            return that.pi;
          },
          resetPan: function() {
            that.resetPan();
            return that.pi;
          },
          reset: function() {
            that.reset();
            return that.pi;
          },
          fit: function() {
            that.fit();
            return that.pi;
          },
          contain: function() {
            that.contain();
            return that.pi;
          },
          center: function() {
            that.center();
            return that.pi;
          },
          updateBBox: function() {
            that.updateBBox();
            return that.pi;
          },
          resize: function() {
            that.resize();
            return that.pi;
          },
          getSizes: function() {
            return {
              width: that.width,
              height: that.height,
              realZoom: that.getZoom(),
              viewBox: that.viewport.getViewBox()
            };
          },
          destroy: function() {
            that.destroy();
            return that.pi;
          }
        };
      }
      return this.publicInstance;
    };
    var instancesStore = [];
    var svgPanZoom = function(elementOrSelector, options) {
      var svg = Utils.getSvg(elementOrSelector);
      if (svg === null) {
        return null;
      } else {
        for (var i = instancesStore.length - 1; i >= 0; i--) {
          if (instancesStore[i].svg === svg) {
            return instancesStore[i].instance.getPublicInstance();
          }
        }
        instancesStore.push({
          svg,
          instance: new SvgPanZoom(svg, options)
        });
        return instancesStore[instancesStore.length - 1].instance.getPublicInstance();
      }
    };
    module2.exports = svgPanZoom;
  }
});

// node_modules/svg-pan-zoom/src/browserify.js
var require_browserify = __commonJS({
  "node_modules/svg-pan-zoom/src/browserify.js"(exports, module2) {
    var SvgPanZoom = require_svg_pan_zoom();
    module2.exports = SvgPanZoom;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZKNavigationPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian13 = require("obsidian");

// src/lang/locale/zh.ts
var zh_default = {
  "ZK main notes": "\u4E3B\u7B14\u8BB0",
  "Main notes folder location": "\u26A0\u4E3B\u7B14\u8BB0\u6587\u4EF6\u5B58\u653E\u4F4D\u7F6E",
  "Specify a folder location to identify main notes": "\u6307\u5B9A\u4E3B\u7B14\u8BB0\u7684\u6587\u4EF6\u5939",
  "Example: folder1/folder2": "\u6BD4\u5982: \u6587\u4EF6\u5939/\u5B50\u6587\u4EF6\u5939",
  "Main notes tag": "\u4E3B\u7B14\u8BB0\u6807\u7B7E",
  "Specify a tag to identify main notes": "\u6307\u5B9A\u4E3B\u7B14\u8BB0\u7684\u6807\u7B7E\uFF08\u53EF\u9009\uFF09",
  "Note ID field options": "\u26A0ID\u5B57\u6BB5\u9009\u9879",
  "Option 1: Filename is note ID": "\u9009\u98791: \u6587\u4EF6\u540D\u4E3AID",
  "Option 2: Metadata is note ID": "\u9009\u98792: \u5C5E\u6027\u5B57\u6BB5\u4E3AID",
  "Option 3: Prefix of filename is note ID": "\u9009\u98793: \u6587\u4EF6\u540D\u524D\u7F00\u4E3AID",
  "Specify a frontmatter field for note's title": "\u26A0\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u5B57\u6BB5\u4F5C\u4E3A\u7B14\u8BB0\u6587\u5B57\u6807\u9898",
  "Specify a frontmatter field for note's ID": "\u26A0\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u5B57\u6BB5\u4F5C\u4E3A\u7B14\u8BB0ID",
  "Specify a separator between ID and title": "\u26A0\u6307\u5B9A\u7B14\u8BB0ID\u548C\u6587\u5B57\u6807\u9898\u7684\u5206\u9694\u7B26",
  '" "(blank)': '" "(\u7A7A\u683C)',
  '"-"(hyphen)': '"-"(\u6A2A\u7EBF)',
  '"_"(underscore)': '"_"(\u4E0B\u5212\u7EBF)',
  "Retrieval": "\u68C0\u7D22\u8BBE\u7F6E",
  "Indexes folder location": "\u26A0\u5173\u952E\u8BCD\u6587\u4EF6\u5B58\u653E\u4F4D\u7F6E",
  "zk-index-graph-view": "\u5173\u952E\u8BCD\u5206\u652F\u89C6\u56FE",
  "Name of index button": "\u6309\u94AE\u540D\u79F0",
  "Suggest mode of index modal": "\u5173\u952E\u8BCD\u67E5\u627E\u6A21\u5F0F",
  "Suggest mode of main note modal": "\u4E3B\u7B14\u8BB0\u67E5\u627E\u6A21\u5F0F",
  "Keyword Order": "\u987A\u5E8F\u67E5\u627E",
  "Fuzzy Suggest": "\u6A21\u7CCA\u67E5\u627E",
  "ID Order": "\u987A\u5E8F\u67E5\u627E",
  "Set red dash line for nodes with ID ends with letter": "ID\u4E3A\u5B57\u6BCD\u7ED3\u5C3E\u7684\u8282\u70B9\u8BBE\u7F6E\u7EA2\u8272\u865A\u7EBF\u6846",
  "In order to distinguish nodes which ID ends with letter and number": "\u533A\u5206: \u6570\u5B57\u7ED3\u5C3EID vs \u5B57\u6BCD\u7ED3\u5C3EID",
  "Fold node toggle": "\u6298\u53E0\u5F00\u5173",
  "Open the fold icon(\u{1F7E1}\u{1F7E2})": "\u70B9\u51FB\u56FE\u6807(\u{1F7E1}\u{1F7E2})\u8FDB\u884C\u6298\u53E0",
  "zk-local-graph-view": "\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "Open close-relative graph": "\u6253\u5F00\u90BB\u8FD1\u89C6\u56FE",
  "Mermaid graph to display father, siblings and sons": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u7684\u7236\u8282\u70B9\uFF0C\u624B\u8DB3\u8282\u70B9\u548C\u5B50\u8282\u70B9",
  "Open inlinks graph": "\u6253\u5F00\u5165\u94FE\u89C6\u56FE",
  "Mermaid graph to display inlinks": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u53CA\u5176\u6240\u6709\u5165\u94FE",
  "Open outlinks graph": "\u6253\u5F00\u51FA\u94FE\u89C6\u56FE",
  "Mermaid graph to display outlinks": "\u663E\u793A\u5F53\u524D\u7B14\u8BB0\u53CA\u5176\u6240\u6709\u51FA\u94FE",
  "Enter a number to set the height of graph in pixels.": "\u8F93\u5165\u4E00\u4E2A\u50CF\u7D20\u503C\u6765\u8BBE\u7F6E\u89C6\u56FE\u7684\u9AD8\u5EA6.",
  "all file extension": "\u68C0\u7D22\u6240\u6709\u7C7B\u578B\u51FA\u94FE",
  ".md only": "\u4EC5\u68C0\u7D22.md\u7C7B\u578B\u51FA\u94FE",
  "Index graph styles": "\u89C6\u56FE\u6837\u5F0F\u8BBE\u7F6E",
  "Height of close-relative graph": "\u90BB\u8FD1\u89C6\u56FE\u9AD8\u5EA6",
  "Height of inlinks graph": "\u5165\u94FE\u89C6\u56FE\u9AD8\u5EA6",
  "Height of outlinks graph": "\u51FA\u94FE\u89C6\u56FE\u9AD8\u5EA6",
  "direction of graph": "\u6811\u72B6\u56FE\u65B9\u5411",
  '"LR": feft to right': '"LR": \u4ECE\u5DE6\u5230\u53F3',
  '"RL": right to left': '"RL": \u4ECE\u53F3\u5230\u5DE6',
  '"TB": top to bottom': '"TB": \u4ECE\u4E0A\u5230\u4E0B',
  '"BT": bottom to top': '"BT": \u4ECE\u4E0B\u5230\u4E0A',
  "Detect file extensions": "\u9650\u5B9A\u51FA\u94FE\u7684\u6587\u4EF6\u7C7B\u578B",
  "Toolbar": "\u56FE\u6807\u5DE5\u5177\u680F",
  "Open the icons(commands) in the branch graph.": "\u6253\u5F00\u5173\u952E\u8BCD\u5206\u652F\u89C6\u56FE\u7684\u56FE\u6807\u547D\u4EE4\u680F.",
  "Index button": "\u5173\u952E\u8BCD\u68C0\u7D22\u6309\u94AE",
  "Main Notes button": "\u4E3B\u7B14\u8BB0\u68C0\u7D22\u6309\u94AE",
  "Name of main note button": "\u6309\u94AE\u540D\u79F0",
  "Custom created time(optional)": "\u4E3B\u7B14\u8BB0\u521B\u5EFA\u65F6\u95F4\uFF08\u81EA\u5B9A\u4E49\u5B57\u6BB5\uFF09",
  "Specify a frontmatter field for time of note created time": "\u6307\u5B9A\u4E00\u4E2A\u5C5E\u6027\u5B57\u6BB5\u4F5C\u4E3A\u4E3B\u7B14\u8BB0\u7684\u521B\u5EFA\u65F6\u95F4",
  "History List": "\u68C0\u7D22\u8BB0\u5F55",
  "And set the list length": "\u8BBE\u7F6E\u6700\u5927\u6253\u5F00\u8BB0\u5F55\u6761\u6570",
  "list tree": "\u5927\u7EB2\u89C6\u56FE",
  "set default width and height for cards": "\u8BBE\u7F6E\u5361\u7247\u5BBD\u5EA6\u4E0E\u9AD8\u5EA6",
  "card width": "\u5361\u7247\u5BBD\u5EA6",
  "card height": "\u5361\u7247\u9AD8\u5EA6",
  "set the fixed path for exported canvas file": "\u26A0\u8BBE\u7F6E\u4E00\u4E2A\u56FA\u5B9A\u7684\u767D\u677F\u6587\u4EF6",
  "if empty, it will create a new canvas file every time": "\u5982\u679C\u4E0D\u8BBE\u7F6E\uFF0C\u6BCF\u6B21\u90FD\u4F1A\u4EA7\u751F\u4E00\u4E2A\u65B0\u7684\u767D\u677F\u6587\u4EF6",
  "Example: folder/filename.canvas": "\u6BD4\u5982: \u6587\u4EF6\u5939/\u6587\u4EF6\u540D.canvas",
  "siblings order": "\u624B\u8DB3\u8282\u70B9\uFF08\u540C\u7EA7\uFF09\u6392\u5E8F",
  "siblings order description": "\u3010\u6570\u5B57\u4F18\u5148\u3011: 1->2...->a->b;\u3010\u5B57\u6BCD\u4F18\u5148\u3011: a->b...->1->2;",
  "number first": "\u6570\u5B57\u4F18\u5148",
  "letter first": "\u5B57\u6BCD\u4F18\u5148",
  "Display from : ": "\u8D77\u70B9\uFF1A",
  "To : ": "\u7EC8\u70B9\uFF1A",
  "Text : ": "\u663E\u793A\u6587\u672C\uFF1A",
  "father": "\u7236\u8282\u70B9",
  "branch": "\u5206\u652F\u5165\u53E3",
  "root": "\u6839\u8282\u70B9",
  "next": "\u5411\u4E0B\u4E00\u5C42",
  "end": "\u6700\u540E\u4E00\u5C42",
  "title": "\u6807\u9898",
  "both": "id + \u6807\u9898",
  "Current index: ": "\u5F53\u524D\u5173\u952E\u8BCD:",
  "random index": "\u968F\u673A\u5173\u952E\u8BCD",
  "random main note": "\u968F\u673A\u4E3B\u7B14\u8BB0",
  "\u274CSetting error: no folder or tag specified for main notes!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u6CA1\u6709\u4E3A\u4E3B\u7B14\u8BB0\u6307\u5B9A\u6587\u4EF6\u5939\u6216\u6807\u7B7E!",
  "\u274CSetting error: no folder specified for index!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u6CA1\u6709\u4E3A\u5173\u952E\u8BCD\u6307\u5B9A\u6587\u4EF6\u5939!",
  "Index: ": "\u5173\u952E\u8BCD: ",
  "has no valid main note outlinks": "\u6CA1\u6709\u5305\u542B\u6709\u6548\u4E3B\u7B14\u8BB0\u94FE\u63A5",
  "table view": "\u8868\u683C\u89C6\u56FE",
  "Current note: ": "\u5F53\u524D\u7B14\u8BB0: ",
  "settings": "\u6253\u5F00\u8BBE\u7F6E",
  "export to canvas": "\u5BFC\u51FA\u5230\u767D\u677F",
  "select a main note": "\u9009\u62E9\u4E00\u4E2A\u4E3B\u7B14\u8BB0",
  "select an index": "\u9009\u62E9\u4E00\u4E2A\u5173\u952E\u8BCD",
  "all trees": "\u6240\u6709\u6811",
  "growing animation": "\u64AD\u653E\u5206\u652F\u751F\u957F\u52A8\u753B",
  "close relative": "\u90BB\u8FD1",
  "inlinks": "\u5165\u94FE",
  "outlinks": "\u51FA\u94FE",
  "expand graph": "\u653E\u5927\u663E\u793A",
  "open zk-index-graph": "\u6253\u5F00\u5173\u952E\u8BCD\u5206\u652F\u89C6\u56FE",
  "open zk-local-graph": "\u6253\u5F00\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "zk-index-graph": "\u5173\u952E\u8BCD\u5206\u652F\u89C6\u56FE",
  "zk-local-graph": "\u5C40\u90E8\u5173\u7CFB\u89C6\u56FE",
  "Main notes": "\u{1F4C4}\u4E3B\u7B14\u8BB0",
  "\u{1F4D6}index": "\u{1F4D6}\u5173\u952E\u8BCD",
  "Copy zk-navigation URI": "\u590D\u5236 zk-navigation \u94FE\u63A5",
  "reveal current file in zk-index-graph": "\u5728\u5173\u952E\u8BCD\u5206\u652F\u89C6\u56FE\u663E\u793A\u5F53\u524D\u6587\u4EF6",
  "Index folder not set!": "\u274C\u8BBE\u7F6E\u9519\u8BEF: \u5173\u952E\u8BCD\u6587\u4EF6\u5939\u6CA1\u6709\u8BBE\u7F6E!",
  "No index can be found by path": "\u6307\u5B9A\u6587\u4EF6\u5939\u627E\u4E0D\u5230\u4EFB\u4F55\u5173\u952E\u8BCD\uFF1A",
  "note's ID": "\u7B14\u8BB0\u7F16\u53F7(ID)",
  "note's title": "\u7B14\u8BB0\u6807\u9898",
  "Time of creation": "\u521B\u5EFA\u65F6\u95F4"
};

// src/lang/locale/en.ts
var en_default = {
  "ZK main notes": "Main notes",
  "Main notes folder location": "\u26A0Main notes folder location",
  "Specify a folder location to identify main notes": "Specify a folder location to identify main notes",
  "Example: folder1/folder2": "Example: folder1/folder2",
  "Main notes tag": "Main notes tag",
  "Specify a tag to identify main notes": "Specify a tag to identify main notes(optional)",
  "Note ID field options": "\u26A0Note ID field options",
  "Option 1: Filename is note ID": "Option 1: Filename is note ID",
  "Option 2: Metadata is note ID": "Option 2: Metadata is note ID",
  "Option 3: Prefix of filename is note ID": "Option 3: Prefix of filename is note ID",
  "Specify a frontmatter field for note's title": "\u26A0Specify a frontmatter field for note's title",
  "Specify a frontmatter field for note's ID": "\u26A0Specify a frontmatter field for note's ID",
  "Specify a separator between ID and title": "\u26A0Specify a separator between ID and title",
  '" "(blank)': '" "(blank)',
  '"-"(hyphen)': '"-"(hyphen)',
  '"_"(underscore)': '"_"(underscore)',
  "Retrieval": "Retrieval",
  "Indexes folder location": "\u26A0Index files folder location",
  "zk-index-graph-view": "zk-index-graph-view",
  "Name of index button": "Name of index button",
  "Suggest mode of index modal": "Suggest mode of index modal",
  "Suggest mode of main note modal": "Suggest mode of main note modal",
  "Keyword Order": "Keyword Order",
  "Fuzzy Suggest": "Fuzzy Suggest",
  "ID Order": "ID Order",
  "Set red dash line for nodes with ID ends with letter": "Set red dash line for nodes with ID ends with letter",
  "In order to distinguish nodes which ID ends with letter and number": "In order to distinguish nodes which ID ends with letter or number",
  "Fold node toggle": "Fold node toggle",
  "Open the fold icon(\u{1F7E1}\u{1F7E2})": "Open the fold icon(\u{1F7E1}\u{1F7E2})",
  "zk-local-graph-view": "zk-local-graph-view",
  "Open close-relative graph": "Open close-relative graph",
  "Mermaid graph to display father, siblings and sons": "Mermaid graph to display father, siblings and sons",
  "Open inlinks graph": "Open inlinks graph",
  "Mermaid graph to display inlinks": "Mermaid graph to display inlinks",
  "Open outlinks graph": "Open outlinks graph",
  "Mermaid graph to display outlinks": "Mermaid graph to display outlinks",
  "Enter a number to set the height of graph in pixels.": "Enter a number to set the height of graph in pixels.",
  "all file extension": "all file extension",
  ".md only": ".md only",
  "Index graph styles": "Index graph styles",
  "Height of close-relative graph": "Height of close-relative graph",
  "Height of inlinks graph": "Height of inlinks graph",
  "Height of outlinks graph": "Height of outlinks graph",
  "direction of branch graph": "direction of branch graph",
  '"LR": feft to right': '"LR": feft to right',
  '"RL": right to left': '"RL": right to left',
  '"TB": top to bottom': '"TB": top to bottom',
  '"BT": bottom to top': '"BT": bottom to top',
  "direction of graph": "direction of graph",
  "Detect file extensions": "Detect file extensions",
  "Toolbar": "Icon toolbar",
  "Open the icons(commands) in the branch graph.": "Open the icons(commands) on the index graph view.",
  "Index button": "Index retrieval button",
  "Main Notes button": "Main notes retrieval button",
  "Name of main note button": "Name of main note button",
  "Custom created time(optional)": "Custom created time(used in table view and animation)",
  "Specify a frontmatter field for time of note created time": "Specify a frontmatter field for the time of main note creation",
  "History List": "recent retrieval",
  "And set the list length": "Set the max length",
  "list tree": "outline view",
  "set default width and height for cards": "set default width and height for cards",
  "card width": "card width",
  "card height": "card height",
  "set the fixed path for exported canvas file": "\u26A0set a fixed canvas file",
  "if empty, it will create a new canvas file every time": "if not set, it will create a new canvas file every time",
  "Example: folder/filename.canvas": "Example: folder/filename.canvas",
  "siblings order": "siblings order",
  "siblings order description": "\u3010number first\u3011: 1->2...->a->b;\u3010letter first\u3011: a->b...->1->2",
  "number first": "number first",
  "letter first": "letter first",
  "Display from : ": "Display from : ",
  "To : ": "To : ",
  "Text : ": "Text : ",
  "father": "father",
  "branch": "branch",
  "root": "root",
  "next": "next",
  "end": "end",
  "title": "title",
  "both": "both",
  "Current index: ": "Current index:",
  "random index": "random index",
  "random main note": "random main note",
  "\u274CSetting error: no folder or tag specified for main notes!": "\u274CSetting error: no folder or tag specified for main notes!",
  "\u274CSetting error: no folder specified for index!": "\u274CSetting error: no folder specified for index!",
  "Index: ": "Index: ",
  "has no valid main note outlinks": "has no valid main note outlinks",
  "table view": "table view",
  "Current note: ": "Current note: ",
  "settings": "open settings",
  "export to canvas": "export to canvas",
  "select a main note": "select a main note",
  "select an index": "select an index",
  "all trees": "all trees",
  "growing animation": "start timelapse animation",
  "close relative": "close relative",
  "inlinks": "inlinks",
  "outlinks": "outlinks",
  "expand graph": "expand graph",
  "open zk-index-graph": "open zk-index-graph",
  "open zk-local-graph": "open zk-local-graph",
  "zk-local-graph": "zk-local-graph",
  "zk-index-graph": "zk-index-graph",
  "Main notes": "\u{1F4C4}Main notes",
  "\u{1F4D6}index": "\u{1F4D6}index",
  "Copy zk-navigation URI": "Copy zk-navigation URI",
  "reveal current file in zk-index-graph": "reveal current file in zk-index-graph",
  "Index folder not set!": "\u274CSetting error: Index folder not set!",
  "No index can be found by path": "No index can be found by path",
  "note's ID": "note's ID",
  "note's title": "note's title",
  "Time of creation": "Time of creation"
};

// src/lang/helper.ts
var localeMap = {
  en: en_default,
  zh: zh_default
};
var lang = window.localStorage.getItem("language");
var locale = localeMap[lang || "en"];
function t(text) {
  return locale && locale[text] || en_default[text];
}

// src/settings/settings.ts
var import_obsidian4 = require("obsidian");

// src/suggester/FolderSuggester.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const folders = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((folder) => {
      if (folder instanceof import_obsidian.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        folders.push(folder);
      }
    });
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggester/TagSuggester.ts
var import_obsidian2 = require("obsidian");
var TagSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    return Object.keys(this.app.metadataCache.getTags());
  }
  renderSuggestion(tag, el) {
    el.setText(tag);
  }
  selectSuggestion(tag) {
    this.inputEl.value = tag;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggester/FileSuggester.ts
var import_obsidian3 = require("obsidian");
var FileSuggest = class extends import_obsidian3.AbstractInputSuggest {
  constructor(app, inputEl) {
    super(app, inputEl);
    this.inputEl = inputEl;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles().filter((f) => f.path.endsWith(".canvas"));
    const files = [];
    const lowerCaseInputStr = inputStr.toLowerCase();
    abstractFiles.forEach((file) => {
      if (file instanceof import_obsidian3.TFile && file.path.toLowerCase().contains(lowerCaseInputStr)) {
        files.push(file);
      }
    });
    return files;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/settings/settings.ts
var ZKNavigationSettngTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Zettelkasten Navigation" });
    const settingTabDiv = containerEl.createDiv("zk-setting-tab");
    const topButtonsDiv = settingTabDiv.createDiv("top-buttons-div");
    const mainNoteButton = new import_obsidian4.ButtonComponent(topButtonsDiv);
    mainNoteButton.setButtonText(t("ZK main notes")).onClick(() => {
      this.openTabSection(0, topButtonsDiv);
    });
    const retrievalButton = new import_obsidian4.ButtonComponent(topButtonsDiv);
    retrievalButton.setButtonText(t("Retrieval")).onClick(() => {
      this.openTabSection(1, topButtonsDiv);
    });
    const indexGraphButton = new import_obsidian4.ButtonComponent(topButtonsDiv);
    indexGraphButton.setButtonText(t("zk-index-graph-view")).onClick(() => {
      this.openTabSection(2, topButtonsDiv);
    });
    const localGraphButton = new import_obsidian4.ButtonComponent(topButtonsDiv);
    localGraphButton.setButtonText(t("zk-local-graph-view")).onClick(() => {
      this.openTabSection(3, topButtonsDiv);
    });
    const mainNotesDiv = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian4.Setting(mainNotesDiv).setName(t("Main notes folder location")).setDesc(t("Specify a folder location to identify main notes")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder1/folder2")).setValue(this.plugin.settings.FolderOfMainNotes).onChange((value) => {
        this.plugin.settings.FolderOfMainNotes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian4.Setting(mainNotesDiv).setName(t("Main notes tag")).setDesc(t("Specify a tag to identify main notes")).addSearch((cb) => {
      new TagSuggest(this.app, cb.inputEl);
      cb.setValue(this.plugin.settings.TagOfMainNotes).onChange((value) => {
        this.plugin.settings.TagOfMainNotes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    const IDOption = new import_obsidian4.Setting(mainNotesDiv).setName(t("Note ID field options")).addDropdown((options) => options.addOption("1", t("Option 1: Filename is note ID")).addOption("2", t("Option 2: Metadata is note ID")).addOption("3", t("Option 3: Prefix of filename is note ID")).setValue(this.plugin.settings.IDFieldOption).onChange((value) => {
      this.plugin.settings.IDFieldOption = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    }));
    switch (this.plugin.settings.IDFieldOption) {
      case "1":
        new import_obsidian4.Setting(mainNotesDiv).setName(t("Specify a frontmatter field for note's title")).addText((cb) => cb.setValue(this.plugin.settings.TitleField).onChange((value) => {
          this.plugin.settings.TitleField = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      case "2":
        new import_obsidian4.Setting(mainNotesDiv).setName(t("Specify a frontmatter field for note's ID")).addText((cb) => cb.setValue(this.plugin.settings.IDField).onChange((value) => {
          this.plugin.settings.IDField = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      case "3":
        new import_obsidian4.Setting(mainNotesDiv).setName(t("Specify a separator between ID and title")).addDropdown((options) => options.addOption(" ", t('" "(blank)')).addOption("-", t('"-"(hyphen)')).addOption("_", t('"_"(underscore)')).setValue(this.plugin.settings.Separator).onChange((value) => {
          this.plugin.settings.Separator = value;
          this.plugin.RefreshIndexViewFlag = true;
        }));
        break;
      default:
    }
    new import_obsidian4.Setting(mainNotesDiv).setName(t("Custom created time(optional)")).setDesc(t("Specify a frontmatter field for time of note created time")).addText((cb) => cb.setValue(this.plugin.settings.CustomCreatedTime).onChange((value) => {
      this.plugin.settings.CustomCreatedTime = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const retrievalDiv = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian4.Setting(retrievalDiv).setName(t("Main Notes button")).addToggle((toggle) => toggle.setValue(this.plugin.settings.MainNoteButton).onChange((value) => {
      this.plugin.settings.MainNoteButton = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(MainNoteButtonDiv);
      });
    });
    const MainNoteButtonDiv = retrievalDiv.createDiv("zk-local-section");
    new import_obsidian4.Setting(MainNoteButtonDiv).setName(t("Name of main note button")).addText((cb) => cb.setValue(this.plugin.settings.MainNoteButtonText).onChange((value) => {
      this.plugin.settings.MainNoteButtonText = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(MainNoteButtonDiv).setName(t("Suggest mode of main note modal")).addDropdown((options) => options.addOption("IDOrder", t("ID Order")).addOption("fuzzySuggest", t("Fuzzy Suggest")).setValue(this.plugin.settings.MainNoteSuggestMode).onChange((value) => {
      this.plugin.settings.MainNoteSuggestMode = value;
    }));
    new import_obsidian4.Setting(retrievalDiv).setName(t("Index button")).addToggle((toggle) => toggle.setValue(this.plugin.settings.IndexButton).onChange((value) => {
      this.plugin.settings.IndexButton = value;
      this.plugin.RefreshIndexViewFlag = true;
      this.display();
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(indexButtonDiv);
      });
    });
    const indexButtonDiv = retrievalDiv.createDiv("zk-local-section");
    new import_obsidian4.Setting(indexButtonDiv).setName(t("Indexes folder location")).addSearch((cb) => {
      new FolderSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder1/folder2")).setValue(this.plugin.settings.FolderOfIndexes).onChange((value) => {
        this.plugin.settings.FolderOfIndexes = value;
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian4.Setting(indexButtonDiv).setName(t("Name of index button")).addText((cb) => cb.setValue(this.plugin.settings.IndexButtonText).onChange((value) => {
      this.plugin.settings.IndexButtonText = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(indexButtonDiv).setName(t("Suggest mode of index modal")).addDropdown((options) => options.addOption("keywordOrder", t("Keyword Order")).addOption("fuzzySuggest", t("Fuzzy Suggest")).setValue(this.plugin.settings.SuggestMode).onChange((value) => {
      this.plugin.settings.SuggestMode = value;
    }));
    const indexGraphView = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian4.Setting(indexGraphView).setName(t("Index graph styles")).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(branchSectionDiv);
      });
    });
    const branchSectionDiv = indexGraphView.createDiv("zk-local-section");
    new import_obsidian4.Setting(branchSectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfBranchGraph).onChange((value) => {
      this.plugin.settings.DirectionOfBranchGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchSectionDiv).setName(t("siblings order")).setDesc(t("siblings order description")).addDropdown((options) => options.addOption("number", t("number first")).addOption("letter", t("letter first")).setValue(this.plugin.settings.siblingsOrder).onChange((value) => {
      this.plugin.settings.siblingsOrder = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchSectionDiv).setName(t("Set red dash line for nodes with ID ends with letter")).setDesc(t("In order to distinguish nodes which ID ends with letter and number")).addToggle((toggle) => toggle.setValue(this.plugin.settings.RedDashLine).onChange((value) => {
      this.plugin.settings.RedDashLine = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchSectionDiv).setName(t("Fold node toggle")).setDesc(t("Open the fold icon(\u{1F7E1}\u{1F7E2})")).addToggle((toggle) => toggle.setValue(this.plugin.settings.FoldToggle).onChange((value) => {
      this.plugin.settings.FoldToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(indexGraphView).setName(t("Toolbar")).setDesc(t("Open the icons(commands) in the branch graph.")).addToggle((toggle) => toggle.setValue(this.plugin.settings.BranchToolbra).onChange((value) => {
      this.plugin.settings.BranchToolbra = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(branchToolbarDiv);
      });
    });
    const branchToolbarDiv = indexGraphView.createDiv("zk-local-section");
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("settings")).addToggle((toggle) => toggle.setValue(this.plugin.settings.settingIcon).onChange((value) => {
      this.plugin.settings.settingIcon = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("export to canvas")).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(canvasAdditionSection);
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.exportCanvas).onChange((value) => {
      this.plugin.settings.exportCanvas = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const canvasAdditionSection = branchToolbarDiv.createDiv("zk-local-section");
    new import_obsidian4.Setting(canvasAdditionSection).setName(t("set the fixed path for exported canvas file")).setDesc(t("if empty, it will create a new canvas file every time")).addSearch((cb) => {
      new FileSuggest(this.app, cb.inputEl);
      cb.setPlaceholder(t("Example: folder/filename.canvas")).setValue(this.plugin.settings.canvasFilePath).onChange((value) => {
        if (value.endsWith(".canvas")) {
          this.plugin.settings.canvasFilePath = value;
        } else {
          this.plugin.settings.canvasFilePath = "";
        }
      });
    });
    new import_obsidian4.Setting(canvasAdditionSection).setName(t("set default width and height for cards")).addText((cb) => {
      cb.inputEl.placeholder = t("card width");
      cb.setValue(this.plugin.settings.cardWidth.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.cardWidth = Number(value);
        } else {
          this.plugin.settings.cardWidth = 400;
        }
      });
    }).addText((cb) => {
      cb.inputEl.placeholder = t("card height");
      cb.setValue(this.plugin.settings.cardHeight.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.cardHeight = Number(value);
        } else {
          this.plugin.settings.cardHeight = 240;
        }
      });
    });
    if (this.plugin.settings.IndexButton == true) {
      new import_obsidian4.Setting(branchToolbarDiv).setName(t("random index")).addToggle((toggle) => toggle.setValue(this.plugin.settings.RandomIndex).onChange((value) => {
        this.plugin.settings.RandomIndex = value;
        this.plugin.RefreshIndexViewFlag = true;
      }));
    }
    if (this.plugin.settings.MainNoteButton == true) {
      new import_obsidian4.Setting(branchToolbarDiv).setName(t("random main note")).addToggle((toggle) => toggle.setValue(this.plugin.settings.RandomMainNote).onChange((value) => {
        this.plugin.settings.RandomMainNote = value;
        this.plugin.RefreshIndexViewFlag = true;
      }));
    }
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("all trees")).addToggle((toggle) => toggle.setValue(this.plugin.settings.showAllToggle).onChange((value) => {
      this.plugin.settings.showAllToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("growing animation")).addToggle((toggle) => toggle.setValue(this.plugin.settings.play).onChange((value) => {
      this.plugin.settings.play = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("table view")).addToggle((toggle) => toggle.setValue(this.plugin.settings.TableView).onChange((value) => {
      this.plugin.settings.TableView = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("list tree")).addToggle((toggle) => toggle.setValue(this.plugin.settings.ListTree).onChange((value) => {
      this.plugin.settings.ListTree = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(branchToolbarDiv).setName(t("History List")).setDesc(t("And set the list length")).addSlider((cb) => {
      cb.setLimits(10, 50, 5).setValue(this.plugin.settings.HistoryMaxCount).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.HistoryMaxCount = value;
      });
    }).addToggle((toggle) => toggle.setValue(this.plugin.settings.HistoryToggle).onChange((value) => {
      this.plugin.settings.HistoryToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const localGraphView = settingTabDiv.createDiv("zk-setting-section");
    new import_obsidian4.Setting(localGraphView).setName(t("Open close-relative graph")).setDesc(t("Mermaid graph to display father, siblings and sons")).addToggle((toggle) => toggle.setValue(this.plugin.settings.FamilyGraphToggle).onChange((value) => {
      this.plugin.settings.FamilyGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(familySectionDiv);
      });
    });
    const familySectionDiv = localGraphView.createDiv("zk-local-section");
    new import_obsidian4.Setting(familySectionDiv).setName(t("Height of close-relative graph")).setDesc(t("Enter a number to set the height of graph in pixels.")).addText((cb) => {
      cb.inputEl.placeholder = "200(defaulf)";
      cb.setValue(this.plugin.settings.HeightOfFamilyGraph.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.HeightOfFamilyGraph = Number(value);
        } else {
          this.plugin.settings.HeightOfFamilyGraph = 200;
        }
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian4.Setting(familySectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfFamilyGraph).onChange((value) => {
      this.plugin.settings.DirectionOfFamilyGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(localGraphView).setName(t("Open inlinks graph")).setDesc(t("Mermaid graph to display inlinks")).addToggle((toggle) => toggle.setValue(this.plugin.settings.InlinksGraphToggle).onChange((value) => {
      this.plugin.settings.InlinksGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(inlinksSectionDiv);
      });
    });
    const inlinksSectionDiv = localGraphView.createDiv("zk-local-section");
    new import_obsidian4.Setting(inlinksSectionDiv).setName(t("Height of inlinks graph")).setDesc(t("Enter a number to set the height of graph in pixels.")).addText((cb) => {
      cb.inputEl.placeholder = "200(defaulf)";
      cb.setValue(this.plugin.settings.HeightOfInlinksGraph.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.HeightOfInlinksGraph = Number(value);
        } else {
          this.plugin.settings.HeightOfInlinksGraph = 200;
        }
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian4.Setting(inlinksSectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfInlinksGraph).onChange((value) => {
      this.plugin.settings.DirectionOfInlinksGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(localGraphView).setName(t("Open outlinks graph")).setDesc(t("Mermaid graph to display outlinks")).addToggle((toggle) => toggle.setValue(this.plugin.settings.OutlinksGraphToggle).onChange((value) => {
      this.plugin.settings.OutlinksGraphToggle = value;
      this.plugin.RefreshIndexViewFlag = true;
    })).addExtraButton((cb) => {
      cb.setIcon("settings").onClick(() => {
        this.hideDiv(outlinksSectionDiv);
      });
    });
    const outlinksSectionDiv = localGraphView.createDiv("zk-local-section");
    new import_obsidian4.Setting(outlinksSectionDiv).setName(t("Height of outlinks graph")).setDesc(t("Enter a number to set the height of graph in pixels.")).addText((cb) => {
      cb.inputEl.placeholder = "200(defaulf)";
      cb.setValue(this.plugin.settings.HeightOfOutlinksGraph.toString()).onChange((value) => {
        if (/^[1-9]\d*$/.test(value)) {
          this.plugin.settings.HeightOfOutlinksGraph = Number(value);
        } else {
          this.plugin.settings.HeightOfOutlinksGraph = 200;
        }
        this.plugin.RefreshIndexViewFlag = true;
      });
    });
    new import_obsidian4.Setting(outlinksSectionDiv).setName(t("direction of graph")).addDropdown((options) => options.addOption("LR", t('"LR": feft to right')).addOption("RL", t('"RL": right to left')).addOption("TB", t('"TB": top to bottom')).addOption("BT", t('"BT": bottom to top')).setValue(this.plugin.settings.DirectionOfOutlinksGraph).onChange((value) => {
      this.plugin.settings.DirectionOfOutlinksGraph = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    new import_obsidian4.Setting(outlinksSectionDiv).setName(t("Detect file extensions")).addDropdown((options) => options.addOption("all", t("all file extension")).addOption("md", t(".md only")).setValue(this.plugin.settings.FileExtension).onChange((value) => {
      this.plugin.settings.FileExtension = value;
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.initDiv(topButtonsDiv);
  }
  openTabSection(selectNo, topButtonsDiv) {
    const sections = document.getElementsByClassName("zk-setting-section");
    const buttons = topButtonsDiv.querySelectorAll("button");
    for (let i = 0; i < sections.length; i++) {
      sections[i].setAttribute("style", "display:none");
      buttons[i].removeClass("top-button-select");
    }
    sections[selectNo].setAttribute("style", "display:block");
    buttons[selectNo].addClass("top-button-select");
    this.plugin.settings.SectionTab = selectNo;
  }
  initDiv(topButtonsDiv) {
    this.openTabSection(this.plugin.settings.SectionTab, topButtonsDiv);
  }
  hideDiv(div) {
    if (div.getAttr("style") == "display:block") {
      div.setAttribute("style", "display:none");
    } else {
      div.setAttribute("style", "display:block");
    }
  }
  async hide() {
    if (this.plugin.RefreshIndexViewFlag === true) {
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }
    this.plugin.saveData(this.plugin.settings);
  }
};

// src/view/graphView.ts
var import_obsidian10 = require("obsidian");

// src/view/indexView.ts
var import_obsidian8 = require("obsidian");

// src/modal/indexModal.ts
var import_obsidian5 = require("obsidian");
var indexModal = class extends import_obsidian5.SuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select an index"));
  }
  getSuggestions(query) {
    this.ALL_ZKIndex = [];
    this.query = query;
    const indexPath = this.plugin.settings.FolderOfIndexes;
    if (indexPath == "") {
      new import_obsidian5.Notice(t("Index folder not set!"));
    } else {
      const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(indexPath + "/"));
      if (indexFiles.length == 0) {
        new import_obsidian5.Notice(`${t("No index can be found by path")} "${indexPath}"`);
      }
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      for (let file of indexFiles) {
        let frontLinks = Object.keys(resolvedLinks[file.path]).filter((l) => l.endsWith("md"));
        let outlinks = [];
        if (frontLinks.length > 0) {
          for (let link of frontLinks) {
            let file2 = this.app.vault.getFileByPath(link);
            if (file2 !== null) {
              let outlink = this.MainNotes.find((n) => n.file === file2);
              if (typeof outlink !== "undefined") {
                let count = this.MainNotes.filter((n) => n.IDStr.startsWith(outlink.IDStr)).length;
                outlinks.push(outlink.ID + ` (${count.toString()})`);
              } else {
                outlinks.push(file2.basename);
              }
            }
          }
        }
        this.ALL_ZKIndex.push({ keyword: file.basename, display: `\u3010${file.basename}\u3011: ${outlinks.toString()}`, path: file.path });
      }
      this.ALL_ZKIndex.sort(function(a, b) {
        return a["keyword"].localeCompare(b["keyword"]);
      });
    }
    this.ALL_ZKIndex = this.ALL_ZKIndex.filter((i) => i.keyword.toLowerCase().startsWith(query.toLowerCase()));
    return this.ALL_ZKIndex;
  }
  renderSuggestion(index, el) {
    (0, import_obsidian5.renderMatches)(el, index.display, [[0, this.query.length + 1]]);
  }
  onChooseSuggestion(index, evt) {
    this.index = index;
    this.onSubmit(this.index);
  }
};
var indexFuzzyModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select an index"));
  }
  getItems() {
    this.ALL_ZKIndex = [];
    const indexPath = this.plugin.settings.FolderOfIndexes;
    if (indexPath == "") {
      new import_obsidian5.Notice(t("Index folder not set!"));
    } else {
      const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(indexPath + "/"));
      if (indexFiles.length == 0) {
        new import_obsidian5.Notice(`${t("No index can be found by path")} "${indexPath}"`);
      }
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      for (let file of indexFiles) {
        let frontLinks = Object.keys(resolvedLinks[file.path]).filter((l) => l.endsWith("md"));
        let outlinks = [];
        if (frontLinks.length > 0) {
          for (let link of frontLinks) {
            let file2 = this.app.vault.getFileByPath(link);
            if (file2 !== null) {
              let outlink = this.MainNotes.find((n) => n.file === file2);
              if (typeof outlink !== "undefined") {
                let count = this.MainNotes.filter((n) => n.IDStr.startsWith(outlink.IDStr)).length;
                outlinks.push(outlink.ID + ` (${count.toString()})`);
              } else {
                outlinks.push(file2.basename);
              }
            }
          }
        }
        this.ALL_ZKIndex.push({ keyword: file.basename, display: `\u3010${file.basename}\u3011: ${outlinks.toString()}`, path: file.path });
      }
      this.ALL_ZKIndex.sort(function(a, b) {
        return a["keyword"].localeCompare(b["keyword"]);
      });
    }
    return this.ALL_ZKIndex;
  }
  getItemText(index) {
    return index.display;
  }
  onChooseItem(index, evt) {
    this.index = index;
    this.onSubmit(this.index);
  }
};

// src/modal/mainNoteModal.ts
var import_obsidian6 = require("obsidian");
var mainNoteModal = class extends import_obsidian6.SuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select a main note"));
  }
  getSuggestions(query) {
    let mainNotes = [];
    this.query = query;
    mainNotes = this.MainNotes.filter((node) => node.displayText.toLowerCase().startsWith(query.toLowerCase()));
    return mainNotes;
  }
  renderSuggestion(node, el) {
    (0, import_obsidian6.renderMatches)(el, node.displayText, [[0, this.query.length]]);
  }
  onChooseSuggestion(node, evt) {
    this.selectZKNode = node;
    this.onSubmit(this.selectZKNode);
  }
};
var mainNoteFuzzyModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app, plugin, MainNotes, onSubmit) {
    super(app);
    this.onSubmit = onSubmit;
    this.plugin = plugin;
    this.MainNotes = MainNotes;
    this.setPlaceholder(t("select a main note"));
  }
  getItems() {
    return this.MainNotes;
  }
  getItemText(node) {
    return `${node.ID}: ${node.title}`;
  }
  onChooseItem(selectZKNode, evt) {
    this.selectZKNode = selectZKNode;
    this.onSubmit(this.selectZKNode);
  }
};

// src/modal/tableModal.ts
var import_obsidian7 = require("obsidian");
var tableModal = class extends import_obsidian7.Modal {
  constructor(app, plugin, tableArr) {
    super(app);
    this.data = `|${t("note's ID")}|${t("note's title")}|${t("inlinks")}|${t("outlinks")}|${t("Time of creation")}|
| --- | --- | --- | --- | --- |
`;
    this.plugin = plugin;
    this.tableArr = tableArr;
  }
  onOpen() {
    let { contentEl } = this;
    this.modalEl.addClass("zk-table-container");
    const contentDiv = contentEl.createDiv("zk-table-view");
    contentDiv.id = "zk-table-view";
    this.appendTableLine();
    import_obsidian7.MarkdownRenderer.render(this.app, this.data, contentDiv, "", this.plugin);
    this.addLinkAndPreview();
  }
  appendTableLine() {
    for (let node of this.tableArr) {
      let inlinksStr = "";
      for (let inlink of this.getInlinks(node.file)) {
        inlinksStr = inlinksStr + `<li>[[${inlink.basename}]]</li>`;
      }
      if (inlinksStr !== "") {
        inlinksStr = `<ul>${inlinksStr}</ul>`;
      }
      let outlinkStr = "";
      for (let outlink of this.getOutlinks(node.file)) {
        outlinkStr = outlinkStr + `<li> [[${outlink.basename}]]</li>`;
      }
      if (outlinkStr !== "") {
        outlinkStr = `<ul>${outlinkStr}</ul>`;
      }
      this.data = this.data + `|[[${node.ID}]]|${node.title}|${inlinksStr}|${outlinkStr}|${node.ctime}|
`;
    }
  }
  getInlinks(currentFile) {
    let inlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    for (let src of Object.keys(resolvedLinks)) {
      let link = resolvedLinks[src];
      for (let dest of Object.keys(link)) {
        if (dest === currentFile.path) {
          let inlinkFile = this.app.vault.getFileByPath(src);
          if (inlinkFile !== null) {
            inlinkArr.push(inlinkFile);
          }
        }
      }
    }
    return inlinkArr;
  }
  getOutlinks(currentFile) {
    let outlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    let outlinks = Object.keys(resolvedLinks[currentFile.path]);
    if (this.plugin.settings.FileExtension == "md") {
      outlinks = outlinks.filter((link) => link.endsWith(".md"));
    }
    for (let outlink of outlinks) {
      let outlinkFile = this.app.vault.getFileByPath(outlink);
      if (outlinkFile !== null) {
        outlinkArr.push(outlinkFile);
      }
    }
    return outlinkArr;
  }
  addLinkAndPreview() {
    let tableDiv = document.getElementById("zk-table-view");
    if (tableDiv !== null) {
      let links = tableDiv.getElementsByTagName("a");
      for (let i = 0; i < links.length; i++) {
        let href = links[i].getAttribute("href");
        if (href) {
          let linkStr = href;
          let node = this.tableArr.find((n) => n.ID == linkStr);
          if (node) {
            linkStr = node.file.basename;
          }
          links[i].addEventListener("click", (event) => {
            if (event.ctrlKey) {
              this.app.workspace.openLinkText(linkStr, "", "tab");
            } else {
              this.app.workspace.openLinkText(linkStr, "");
            }
          });
          links[i].addEventListener(`mouseover`, (event) => {
            this.app.workspace.trigger(`hover-link`, {
              event,
              source: ZK_NAVIGATION,
              hoverParent: tableDiv,
              linktext: linkStr,
              targetEl: links[i],
              sourcePath: ""
            });
          });
        }
      }
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/utils/utils.ts
async function ID_formatting(id, arr, siblingsOrder) {
  if (/^[0-9]$/.test(id[0])) {
    let numStr = id.match(/\d+/g);
    if (numStr && numStr.length > 0) {
      arr.push(numStr[0].padStart(4, "0"));
      let len = numStr[0].length;
      if (len < id.length) {
        return await ID_formatting(id.slice(len), arr, siblingsOrder);
      } else {
        return arr;
      }
    } else {
      return arr;
    }
  } else if (/^[a-zA-Z]$/.test(id[0])) {
    let letterStr;
    if (siblingsOrder === "letter") {
      letterStr = id[0].padStart(5, "0");
    } else {
      letterStr = id[0];
    }
    arr.push(letterStr);
    if (id.length === 1) {
      return arr;
    } else {
      return await ID_formatting(id.slice(1), arr, siblingsOrder);
    }
  } else {
    if (id.length === 1) {
      return arr;
    } else {
      return await ID_formatting(id.slice(1), arr, siblingsOrder);
    }
  }
}
async function mainNoteInit(plugin) {
  var _a, _b;
  let mainNoteFiles = this.app.vault.getMarkdownFiles();
  plugin.MainNotes = [];
  if (plugin.settings.FolderOfMainNotes !== "") {
    mainNoteFiles = mainNoteFiles.filter((file) => {
      return file.path.replace(file.name, "").startsWith(plugin.settings.FolderOfMainNotes + "/");
    });
  }
  if (plugin.settings.TagOfMainNotes !== "") {
    mainNoteFiles = mainNoteFiles.filter((file) => {
      var _a2, _b2, _c;
      return (_c = (_b2 = (_a2 = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a2.frontmatter) == null ? void 0 : _b2.tags) == null ? void 0 : _c.includes(plugin.settings.TagOfMainNotes.substring(1));
    });
  }
  for (let note of mainNoteFiles) {
    let IDArr = [];
    let node = {
      ID: "",
      IDArr,
      IDStr: "",
      position: 0,
      file: note,
      title: "",
      displayText: "",
      ctime: "",
      randomId: random(16),
      nodeSons: 1,
      startY: 0,
      height: 0,
      isRoot: false
    };
    let nodeCache = this.app.metadataCache.getFileCache(note);
    switch (plugin.settings.IDFieldOption) {
      case "1":
        node.ID = note.basename;
        node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
        node.IDStr = IDArr.toString();
        if (nodeCache !== null) {
          if (typeof nodeCache.frontmatter !== "undefined" && plugin.settings.TitleField !== "") {
            let title = (_a = nodeCache.frontmatter[plugin.settings.TitleField]) == null ? void 0 : _a.toString();
            if (typeof title == "string" && title.length > 0) {
              node.title = title;
            }
          }
        }
        break;
      case "2":
        if (nodeCache !== null) {
          if (typeof nodeCache.frontmatter !== "undefined" && plugin.settings.IDField !== "") {
            let id = nodeCache.frontmatter[plugin.settings.IDField];
            if (typeof id == "string" && id.length > 0) {
              node.ID = id;
              node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
              node.IDStr = node.IDArr.toString();
              node.title = note.basename;
            }
          }
        }
        if (node.ID == "") {
          continue;
        }
        break;
      case "3":
        node.ID = note.basename.split(plugin.settings.Separator)[0];
        node.IDArr = await ID_formatting(node.ID, node.IDArr, plugin.settings.siblingsOrder);
        node.IDStr = IDArr.toString();
        if (node.ID.length < note.basename.length - 1) {
          node.title = note.basename.substring(node.ID.length + 1);
        }
        break;
      default:
    }
    switch (plugin.settings.NodeText) {
      case "id":
        node.displayText = node.ID;
        break;
      case "title":
        if (node.title == "") {
          node.displayText = node.ID;
        } else {
          node.displayText = node.title;
        }
        break;
      case "both":
        node.displayText = `${node.ID}: ${node.title}`;
        break;
      default:
    }
    if (plugin.settings.CustomCreatedTime.length > 0) {
      let ctime = (_b = nodeCache == null ? void 0 : nodeCache.frontmatter) == null ? void 0 : _b[plugin.settings.CustomCreatedTime];
      if (ctime) {
        node.ctime = ctime.toString();
      }
    }
    if (node.ctime === "") {
      node.ctime = window.moment(node.file.stat.ctime).format("YYYY-MM-DD HH:mm:ss");
    }
    plugin.MainNotes.push(node);
  }
  plugin.MainNotes.sort((a, b) => a.IDStr.localeCompare(b.IDStr));
  for (let i = 0; i < plugin.MainNotes.length; i++) {
    let node = plugin.MainNotes[i];
    node.position = i;
    if (!plugin.MainNotes.find((n) => n.IDArr.toString() == node.IDArr.slice(0, -1).toString())) {
      node.isRoot = true;
    }
  }
}
var random = (e) => {
  let t2 = [];
  for (let n = 0; n < e; n++) {
    t2.push((16 * Math.random() | 0).toString(16));
  }
  return t2.join("");
};

// src/view/indexView.ts
var ZK_INDEX_TYPE = "zk-index-type";
var ZK_INDEX_VIEW = t("zk-index-graph");
var ZK_NAVIGATION = "zk-navigation";
var ZKIndexView = class extends import_obsidian8.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshIndexLayout = async () => {
      if (this.plugin.settings.FolderOfMainNotes == "" && this.plugin.settings.TagOfMainNotes == "") {
        new import_obsidian8.Notice(t("\u274CSetting error: no folder or tag specified for main notes!"));
        return;
      } else {
        await this.IndexViewInterfaceInit();
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_INDEX_TYPE;
  }
  getDisplayText() {
    return ZK_INDEX_VIEW;
  }
  getIcon() {
    return "ghost";
  }
  onResize() {
    if (this.containerEl.offsetHeight !== 0) {
      if (this.plugin.indexViewOffsetHeight !== this.containerEl.offsetHeight || this.plugin.indexViewOffsetWidth !== this.containerEl.offsetWidth) {
        this.app.workspace.trigger("zk-navigation:refresh-index-graph");
      }
    }
  }
  async IndexViewInterfaceInit() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.addClass("zk-view-content");
    const toolbarDiv = containerEl.createDiv("zk-index-toolbar");
    const indexMermaidDiv = containerEl.createDiv("zk-index-mermaid-container");
    indexMermaidDiv.id = "zk-index-mermaid-container";
    indexMermaidDiv.empty();
    if (this.plugin.settings.MainNoteButton == true) {
      const mainNoteButtonDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
      const mainNoteButton = new import_obsidian8.ButtonComponent(mainNoteButtonDiv).setClass("zk-index-toolbar-button");
      mainNoteButton.setButtonText(this.plugin.settings.MainNoteButtonText);
      mainNoteButton.setCta();
      mainNoteButton.onClick(() => {
        if (this.plugin.settings.MainNoteSuggestMode === "IDOrder") {
          new mainNoteModal(this.app, this.plugin, this.plugin.MainNotes, (selectZKNode) => {
            this.plugin.settings.SelectMainNote = selectZKNode.file.path;
            this.plugin.settings.SelectIndex = "";
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        } else {
          new mainNoteFuzzyModal(this.app, this.plugin, this.plugin.MainNotes, (selectZKNode) => {
            this.plugin.settings.SelectMainNote = selectZKNode.file.path;
            this.plugin.settings.SelectIndex = "";
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        }
      });
    }
    if (this.plugin.settings.IndexButton == true) {
      const indexButtonDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
      const indexButton = new import_obsidian8.ButtonComponent(indexButtonDiv).setClass("zk-index-toolbar-button");
      indexButton.setButtonText(this.plugin.settings.IndexButtonText);
      indexButton.setCta();
      indexButton.onClick(() => {
        if (this.plugin.settings.SuggestMode === "keywordOrder") {
          new indexModal(this.app, this.plugin, this.plugin.MainNotes, (index) => {
            this.plugin.settings.SelectIndex = index.path;
            this.plugin.settings.SelectMainNote = "";
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        } else {
          new indexFuzzyModal(this.app, this.plugin, this.plugin.MainNotes, (index) => {
            this.plugin.settings.SelectIndex = index.path;
            this.plugin.settings.SelectMainNote = "";
            this.plugin.clearShowingSettings();
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }).open();
        }
      });
    }
    const startingDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    startingDiv.createEl("b", { text: t("Display from : ") });
    const startPoint = new import_obsidian8.DropdownComponent(startingDiv);
    startPoint.addOption("father", t("father")).addOption("branch", t("branch")).addOption("root", t("root")).setValue(this.plugin.settings.StartingPoint).onChange((StartPoint) => {
      this.plugin.settings.StartingPoint = StartPoint;
      this.plugin.clearShowingSettings(this.plugin.settings.BranchTab);
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    });
    const displayLevelDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    displayLevelDiv.createEl("b", { text: t("To : ") });
    const displayLevel = new import_obsidian8.DropdownComponent(displayLevelDiv);
    displayLevel.addOption("next", t("next")).addOption("end", t("end")).setValue(this.plugin.settings.DisplayLevel).onChange((DisplayLevel) => {
      this.plugin.settings.DisplayLevel = DisplayLevel;
      this.plugin.clearShowingSettings(this.plugin.settings.BranchTab);
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    });
    const nodeTextDiv = toolbarDiv.createDiv("zk-index-toolbar-block");
    nodeTextDiv.createEl("b", { text: t("Text : ") });
    const nodeText = new import_obsidian8.DropdownComponent(nodeTextDiv);
    nodeText.addOption("id", "id").addOption("title", t("title")).addOption("both", t("both")).setValue(this.plugin.settings.NodeText).onChange((NodeText) => {
      this.plugin.settings.NodeText = NodeText;
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
      ;
    });
    await this.refreshBranchMermaid();
    if (this.plugin.settings.SelectIndex == "" && this.plugin.settings.SelectMainNote == "" && this.plugin.settings.showAll == false) {
      let index = Math.floor(Math.random() * this.plugin.MainNotes.length);
      this.plugin.settings.SelectMainNote = this.plugin.MainNotes[index].file.path;
      await this.refreshBranchMermaid();
    }
  }
  async onload() {
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      if ((leaf == null ? void 0 : leaf.view.getViewType()) == ZK_INDEX_TYPE) {
        if (this.plugin.RefreshIndexViewFlag == true) {
          await this.IndexViewInterfaceInit();
        }
      }
    }));
    this.registerEvent(this.app.vault.on("rename", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.vault.on("create", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.vault.on("delete", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.metadataCache.on("changed", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    this.registerEvent(this.app.metadataCache.on("deleted", async () => {
      this.plugin.RefreshIndexViewFlag = true;
    }));
    const refresh = (0, import_obsidian8.debounce)(this.refreshIndexLayout, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-index-graph", refresh));
  }
  async onOpen() {
    if (this.app.workspace.layoutReady) {
      this.refreshIndexLayout();
    } else {
      this.app.workspace.onLayoutReady(() => {
        this.refreshIndexLayout();
      });
    }
  }
  async refreshBranchMermaid() {
    var _a;
    const indexMermaidDiv = document.getElementById("zk-index-mermaid-container");
    if (!indexMermaidDiv)
      return;
    await mainNoteInit(this.plugin);
    indexMermaidDiv.empty();
    let branchEntranceNodeArr = [];
    let indexFile;
    const indexLinkDiv = indexMermaidDiv.createDiv("zk-index-link");
    indexLinkDiv.empty();
    if (this.plugin.settings.BranchToolbra == true) {
      const toolButtonsDiv = indexMermaidDiv.createDiv("zk-tool-buttons");
      toolButtonsDiv.empty();
      if (this.plugin.settings.settingIcon == true) {
        const settingBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        settingBtn.setIcon("settings").setTooltip(t("settings"));
        settingBtn.onClick(() => {
          this.app.setting.open();
          this.app.setting.openTabById("zettelkasten-navigation");
        });
      }
      if (this.plugin.settings.exportCanvas == true) {
        const canvasBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        canvasBtn.setIcon("layout-dashboard").setTooltip(t("export to canvas"));
        canvasBtn.onClick(async () => {
          await this.exportToCanvas();
        });
      }
      if (this.plugin.settings.RandomMainNote == true && this.plugin.settings.MainNoteButton) {
        const randomBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        randomBtn.setIcon("dice-3").setTooltip(t("random main note"));
        randomBtn.onClick(async () => {
          if (this.plugin.settings.FolderOfMainNotes == "" && this.plugin.settings.TagOfMainNotes == "") {
            new import_obsidian8.Notice(t("\u274CSetting error: no folder or tag specified for main notes!"));
            return;
          } else {
            let randomMainNoteNode = this.plugin.MainNotes[Math.floor(Math.random() * this.plugin.MainNotes.length)];
            this.plugin.settings.SelectMainNote = randomMainNoteNode.file.path;
            this.plugin.settings.SelectIndex = "";
            await this.plugin.clearShowingSettings();
            await this.IndexViewInterfaceInit();
          }
        });
      }
      if (this.plugin.settings.RandomIndex == true && this.plugin.settings.IndexButton) {
        const randomBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        randomBtn.setIcon("dices").setTooltip(t("random index"));
        randomBtn.onClick(async () => {
          if (this.plugin.settings.FolderOfIndexes == "") {
            new import_obsidian8.Notice(t("\u274CSetting error: no folder specified for index!"));
            return;
          } else {
            const indexFiles = this.app.vault.getMarkdownFiles().filter((f) => f.path.startsWith(this.plugin.settings.FolderOfIndexes + "/"));
            let randomIndex = indexFiles[Math.floor(Math.random() * indexFiles.length)];
            this.plugin.settings.SelectIndex = randomIndex.path;
            this.plugin.settings.SelectMainNote = "";
            await this.plugin.clearShowingSettings();
            await this.IndexViewInterfaceInit();
          }
        });
      }
      if (this.plugin.settings.showAllToggle == true) {
        const showAllBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        showAllBtn.setIcon("trees").setTooltip(t("all trees"));
        showAllBtn.onClick(async () => {
          this.plugin.settings.SelectIndex = "";
          this.plugin.settings.SelectMainNote = "";
          this.plugin.settings.showAll = true;
          this.plugin.settings.DisplayLevel = "end";
          await this.plugin.clearShowingSettings();
          await this.IndexViewInterfaceInit();
        });
      }
      if (this.plugin.settings.play == true) {
        const playBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        playBtn.setIcon("wand-2").setTooltip(t("growing animation"));
        playBtn.onClick(() => {
          this.plugin.settings.FoldNodeArr = [];
          this.branchGrowing();
        });
      }
      if (this.plugin.settings.TableView == true) {
        const tableBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        tableBtn.setIcon("table").setTooltip(t("table view"));
        tableBtn.onClick(async () => {
          await this.genericBranchNodes();
          new tableModal(this.app, this.plugin, this.plugin.tableArr).open();
        });
      }
      if (this.plugin.settings.ListTree == true) {
        const listBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        listBtn.setIcon("list-tree").setTooltip(t("list tree"));
        listBtn.onClick(async () => {
          await this.genericBranchNodes();
          this.plugin.openOutlineView();
        });
      }
      if (this.plugin.settings.HistoryToggle == true) {
        const historyBtn = new import_obsidian8.ExtraButtonComponent(toolButtonsDiv);
        historyBtn.setIcon("history").setTooltip(t("History List"));
        historyBtn.onClick(async () => {
          this.plugin.openRecentView();
        });
      }
    }
    if (this.plugin.settings.SelectIndex != "") {
      if (!this.plugin.settings.SelectIndex.startsWith(this.plugin.settings.FolderOfIndexes))
        return;
      branchEntranceNodeArr = await this.getBranchEntranceNode(this.plugin.settings.SelectIndex);
      indexLinkDiv.createEl("abbr", { text: t("Current index: ") });
      indexFile = this.app.vault.getFileByPath(this.plugin.settings.SelectIndex);
      this.unshiftHistoryList(indexFile.basename, indexFile.path);
    } else if (this.plugin.settings.SelectMainNote != "") {
      let selectZKNode = this.plugin.MainNotes.filter((n) => n.file.path == this.plugin.settings.SelectMainNote)[0];
      if (typeof selectZKNode === "undefined") {
        new import_obsidian8.Notice(`Invalid main note: ${this.plugin.settings.SelectMainNote}`);
        return;
      }
      branchEntranceNodeArr.push(selectZKNode);
      indexLinkDiv.createEl("abbr", { text: t("Current note: ") });
      indexFile = this.app.vault.getFileByPath(this.plugin.settings.SelectMainNote);
      this.unshiftHistoryList(selectZKNode.displayText, selectZKNode.file.path);
    } else if (this.plugin.settings.showAll == true) {
      indexLinkDiv.createEl("abbr", { text: t("all trees") });
      branchEntranceNodeArr = this.plugin.MainNotes.filter((n) => n.isRoot == true);
    }
    if (indexFile instanceof import_obsidian8.TFile) {
      let link = indexLinkDiv.createEl("a", { text: `\u3010${indexFile.basename}\u3011` });
      if (this.plugin.settings.SelectMainNote != "") {
        link.empty();
        let node = this.plugin.MainNotes.filter((n) => n.file.path == this.plugin.settings.SelectMainNote)[0];
        if (node) {
          link = indexLinkDiv.createEl("a", { text: `\u3010${node.displayText}\u3011` });
        }
      }
      link.addEventListener("click", (event) => {
        if (event.ctrlKey) {
          this.app.workspace.openLinkText("", indexFile.path, "tab");
        } else {
          this.app.workspace.openLinkText("", indexFile.path);
        }
      });
      link.addEventListener(`mouseover`, (event) => {
        this.app.workspace.trigger(`hover-link`, {
          event,
          source: ZK_NAVIGATION,
          hoverParent: link,
          linktext: indexFile.basename,
          targetEl: link,
          sourcePath: indexFile.path
        });
      });
    }
    if (branchEntranceNodeArr.length > 0) {
      const mermaid = await (0, import_obsidian8.loadMermaid)();
      this.branchAllNodes = [];
      for (let i = 0; i < branchEntranceNodeArr.length; i++) {
        const branchNodes = await this.getBranchNodes(branchEntranceNodeArr[i]);
        this.branchAllNodes.push({ branchTab: i, branchNodes });
        let branchMermaidStr = await this.genericIndexMermaidStr(branchNodes, branchEntranceNodeArr[i], this.plugin.settings.DirectionOfBranchGraph);
        let zkGraph = indexMermaidDiv.createEl("div", { cls: "zk-index-mermaid" });
        zkGraph.id = `zk-index-mermaid-${i}`;
        let { svg } = await mermaid.render(`${zkGraph.id}-svg`, branchMermaidStr);
        zkGraph.insertAdjacentHTML("beforeend", svg);
        zkGraph.children[0].setAttribute("width", "100%");
        zkGraph.children[0].setAttr("height", `${this.containerEl.offsetHeight - 100}px`);
        indexMermaidDiv.appendChild(zkGraph);
        const svgPanZoom = require_browserify();
        let panZoomTiger = await svgPanZoom(`#${zkGraph.id}-svg`, {
          zoomEnabled: true,
          controlIconsEnabled: false,
          fit: true,
          center: true,
          minZoom: 1e-3,
          maxZoom: 1e3,
          dblClickZoomEnabled: false,
          zoomScaleSensitivity: 0.2,
          onZoom: async () => {
            this.plugin.settings.zoomPanScaleArr[i].zoomScale = panZoomTiger.getZoom();
          },
          onPan: async () => {
            this.plugin.settings.zoomPanScaleArr[i].pan = panZoomTiger.getPan();
          }
        });
        if (typeof this.plugin.settings.zoomPanScaleArr[i] === "undefined") {
          const setSvg = document.getElementById(`${zkGraph.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (a) {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
            let zoomPanScale = {
              graphID: zkGraph.id,
              zoomScale: panZoomTiger.getZoom(),
              pan: panZoomTiger.getPan()
            };
            this.plugin.settings.zoomPanScaleArr.push(zoomPanScale);
          }
        } else {
          panZoomTiger.zoom(this.plugin.settings.zoomPanScaleArr[i].zoomScale);
          panZoomTiger.pan(this.plugin.settings.zoomPanScaleArr[i].pan);
        }
        const indexMermaid = document.getElementById(zkGraph.id);
        if (indexMermaid !== null) {
          for (let foldNode of this.plugin.settings.FoldNodeArr.filter((n) => n.graphID == zkGraph.id)) {
            let hideNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(foldNode.nodeIDstr) && n.IDStr !== foldNode.nodeIDstr);
            for (let hideNode of hideNodes) {
              let hideNodeGArr = indexMermaid.querySelectorAll(`[id^='flowchart-${hideNode.position}']`);
              hideNodeGArr.forEach((item) => {
                item.setAttribute("style", "display:none");
              });
              let hideLines2 = indexMermaid.querySelectorAll(`[id^='L-${hideNode.position}']`);
              hideLines2.forEach((item) => {
                item.setAttribute("style", "display:none");
              });
            }
            let hideLines = indexMermaid.querySelectorAll(`[id^='L-${foldNode.position}']`);
            hideLines.forEach((item) => {
              item.setAttribute("style", "display:none");
            });
          }
          let nodeGArr = indexMermaid.querySelectorAll("[id^='flowchart-']");
          let flowchartG = indexMermaid.querySelector("g.nodes");
          if (flowchartG !== null) {
            let nodeArr = flowchartG.getElementsByClassName("nodeLabel");
            for (let i2 = 0; i2 < nodeArr.length; i2++) {
              let link = document.createElement("a");
              link.addClass("internal-link");
              let nodePosStr = nodeGArr[i2].id.split("-")[1];
              let node = this.plugin.MainNotes.filter((n) => n.position == Number(nodePosStr))[0];
              link.textContent = nodeArr[i2].getText();
              nodeArr[i2].textContent = "";
              nodeArr[i2].appendChild(link);
              nodeArr[i2].addEventListener("click", async (event) => {
                if (event.ctrlKey) {
                  this.app.workspace.openLinkText("", node.file.path, "tab");
                  event.stopPropagation();
                }
              });
              nodeGArr[i2].addEventListener("click", async (event) => {
                if (event.ctrlKey) {
                  navigator.clipboard.writeText(node.ID);
                  new import_obsidian8.Notice(node.ID + " copied");
                } else if (event.shiftKey) {
                  this.plugin.settings.SelectIndex = "";
                  this.plugin.settings.SelectMainNote = node.file.path;
                  await this.plugin.clearShowingSettings();
                  await this.IndexViewInterfaceInit();
                } else if (event.altKey) {
                  this.plugin.FileforLocaLgraph = node.file.path;
                  this.plugin.openGraphView();
                } else {
                  this.app.workspace.openLinkText("", node.file.path);
                }
              });
              nodeGArr[i2].addEventListener(`mouseover`, (event) => {
                this.app.workspace.trigger(`hover-link`, {
                  event,
                  source: ZK_NAVIGATION,
                  hoverParent: this,
                  linktext: node.file.basename,
                  targetEl: link,
                  sourcePath: node.file.path
                });
              });
              if (this.plugin.settings.FoldToggle == true) {
                let foldIcon = document.createElement("span");
                (_a = nodeArr[i2].parentNode) == null ? void 0 : _a.insertAfter(foldIcon, nodeArr[i2]);
                if (typeof this.plugin.settings.FoldNodeArr.find((n) => n.nodeIDstr == node.IDStr && n.graphID == zkGraph.id) === "undefined") {
                  foldIcon.textContent = "\u{1F7E1}";
                } else {
                  foldIcon.textContent = "\u{1F7E2}";
                }
                foldIcon.addEventListener("click", async (event) => {
                  let foldNode = {
                    graphID: zkGraph.id,
                    nodeIDstr: node.IDStr,
                    position: node.position
                  };
                  if (this.plugin.settings.FoldNodeArr.length === 0) {
                    if (this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(node.IDStr)).length > 1) {
                      this.plugin.settings.FoldNodeArr.push(foldNode);
                    }
                  } else {
                    if (typeof this.plugin.settings.FoldNodeArr.find((n) => n.nodeIDstr == node.IDStr && (n.graphID = zkGraph.id)) === "undefined") {
                      if (this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(node.IDStr)).length > 1) {
                        this.plugin.settings.FoldNodeArr.push(foldNode);
                      }
                    } else {
                      this.plugin.settings.FoldNodeArr = this.plugin.settings.FoldNodeArr.filter((n) => !(n.graphID == foldNode.graphID && n.nodeIDstr == foldNode.nodeIDstr));
                    }
                  }
                  if (foldIcon.textContent === "\u{1F7E2}" && event.ctrlKey) {
                    this.plugin.settings.FoldNodeArr = this.plugin.settings.FoldNodeArr.filter((n) => !n.nodeIDstr.startsWith(foldNode.nodeIDstr));
                  }
                  event.stopPropagation();
                  await this.refreshBranchMermaid();
                });
              }
            }
          }
        }
      }
      if (branchEntranceNodeArr.length > 1) {
        const branchTabs = document.getElementsByClassName("zk-index-mermaid");
        indexLinkDiv.createEl("small", { text: ` >> ` });
        for (let i = 0; i < branchTabs.length; i++) {
          let branchTab = indexLinkDiv.createEl("span").createEl("a", { text: `\u{1F33F}${i + 1} `, cls: "zK-branch-tab" });
          let node = branchEntranceNodeArr[i];
          (0, import_obsidian8.setTooltip)(branchTab, `${node.displayText} (${this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(node.IDStr)).length})`);
          branchTab.addEventListener("click", async () => {
            await this.openBranchTab(i);
          });
        }
        await this.openBranchTab(this.plugin.settings.BranchTab);
      }
    }
    if (this.plugin.settings.ListTree === true) {
      await this.genericBranchNodes();
      this.app.workspace.trigger("zk-navigation:refresh-outline-view");
    }
    if (this.plugin.settings.HistoryToggle === true) {
      this.app.workspace.trigger("zk-navigation:refresh-recent-view");
    }
    this.plugin.indexViewOffsetWidth = this.containerEl.offsetWidth;
    this.plugin.indexViewOffsetHeight = this.containerEl.offsetHeight;
  }
  async openBranchTab(tabNo) {
    this.plugin.settings.BranchTab = tabNo;
    const branchGraph = document.getElementsByClassName("zk-index-mermaid");
    const branchTabs = document.querySelectorAll('[class^="zK-branch-tab"]');
    for (let i = 0; i < branchGraph.length; i++) {
      branchGraph[i].setAttribute("style", "display:none");
      branchTabs[i].className = "zK-branch-tabs";
    }
    branchGraph[tabNo].setAttribute("style", "display:block");
    branchTabs[tabNo].className = "zK-branch-tab-select";
    if (this.plugin.settings.ListTree === true) {
      await this.genericBranchNodes();
      this.app.workspace.trigger("zk-navigation:refresh-outline-view");
    }
  }
  async getBranchEntranceNode(index) {
    let branchNodeArr = [];
    const indexFile = this.app.vault.getFileByPath(index);
    if (indexFile !== null) {
      const resolvedLinks = this.app.metadataCache.resolvedLinks;
      let frontLinks = Object.keys(resolvedLinks[indexFile.path]).filter((l) => l.endsWith("md"));
      if (frontLinks.length > 0) {
        for (let link of frontLinks) {
          let branchFile = this.app.vault.getFileByPath(link);
          if (branchFile) {
            let nodes = this.plugin.MainNotes.filter((l) => l.file.path == (branchFile == null ? void 0 : branchFile.path));
            if (nodes.length > 0) {
              branchNodeArr.push(nodes[0]);
            }
          }
        }
      }
      if (this.plugin.settings.SelectIndex !== "" && branchNodeArr.length == 0) {
        new import_obsidian8.Notice(`${t("Index: ")}\u3010${indexFile.basename}\u3011${t("has no valid main note outlinks")}`);
      }
    }
    return branchNodeArr;
  }
  async getBranchNodes(entranceNode) {
    let branchNodes = [];
    let startNode = entranceNode;
    switch (this.plugin.settings.StartingPoint) {
      case "root":
        let frontNodes = this.plugin.MainNotes.filter((n) => entranceNode.IDStr.startsWith(n.IDStr));
        if (frontNodes.length > 0) {
          startNode = frontNodes[0];
        } else {
          new import_obsidian8.Notice("Can't find the root of the branch!");
        }
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(startNode.IDStr));
        break;
      case "father":
        if (entranceNode.IDArr.length > 1) {
          let fatherArr = entranceNode.IDArr.slice(0, entranceNode.IDArr.length - 1);
          let fatherNode = this.plugin.MainNotes.find((n) => n.IDStr == fatherArr.toString());
          if (typeof fatherNode !== "undefined") {
            startNode = fatherNode;
          } else {
            startNode = entranceNode;
          }
        } else {
          startNode = entranceNode;
        }
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(startNode.IDStr)).filter((n) => n.IDStr.startsWith(entranceNode.IDStr) || n.IDArr.length <= entranceNode.IDArr.length);
        break;
      default:
        branchNodes = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(entranceNode.IDStr));
    }
    if (this.plugin.settings.DisplayLevel == "next") {
      branchNodes = branchNodes.filter((n) => !n.IDStr.startsWith(entranceNode.IDStr) || n.IDArr.length <= entranceNode.IDArr.length + 1);
    }
    return branchNodes;
  }
  async genericIndexMermaidStr(Nodes, entranceNode, direction) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'basis' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction};
`;
    for (let node of Nodes) {
      mermaidStr = mermaidStr + `${node.position}("${node.displayText}");
`;
      if (node.IDStr.startsWith(entranceNode.IDStr)) {
        mermaidStr = mermaidStr + `style ${node.position} fill:#ffa,stroke:#333,stroke-width:1px 
`;
      } else {
        mermaidStr = mermaidStr + `style ${node.position} fill:#fff; 
`;
      }
    }
    for (let node of Nodes) {
      let sonNodes = Nodes.filter((n) => n.IDArr.length - 1 == node.IDArr.length && n.IDStr.startsWith(node.IDStr) && n.ID.startsWith(node.ID));
      for (let son of sonNodes) {
        mermaidStr = mermaidStr + `${node.position} ---> ${son.position};
`;
      }
    }
    if (this.plugin.settings.RedDashLine === true) {
      for (let node of Nodes) {
        if (/^[a-zA-Z]$/.test(node.ID.slice(-1))) {
          mermaidStr = mermaidStr + `style ${node.position} stroke:#f66,stroke-width:2px,stroke-dasharray: 1 
`;
        }
      }
    }
    return mermaidStr;
  }
  unshiftHistoryList(displayText, filePath) {
    let a = this.plugin.settings.HistoryList.find((n) => n.filePath == filePath);
    if (a) {
      let index = this.plugin.settings.HistoryList.indexOf(a);
      if (index > -1) {
        this.plugin.settings.HistoryList.splice(index, 1);
      }
    }
    let history = {
      displayText,
      filePath,
      openTime: (0, import_obsidian8.moment)().format("YYYY-MM-DD HH:mm:ss")
    };
    this.plugin.settings.HistoryList.unshift(history);
    if (this.plugin.settings.HistoryList.length > this.plugin.settings.HistoryMaxCount) {
      this.plugin.settings.HistoryList = this.plugin.settings.HistoryList.slice(0, this.plugin.settings.HistoryMaxCount);
    }
  }
  async genericBranchNodes() {
    this.plugin.tableArr = [];
    const tableBranch = document.getElementById(`zk-index-mermaid-${this.plugin.settings.BranchTab}-svg`);
    if (tableBranch !== null) {
      let nodeGArr = tableBranch.querySelectorAll("[id^='flowchart-']");
      for (let i = 0; i < nodeGArr.length; i++) {
        let nodePosStr = nodeGArr[i].id.split("-")[1];
        let node = this.plugin.MainNotes.filter((n) => n.position == Number(nodePosStr))[0];
        this.plugin.tableArr.push(node);
      }
    }
  }
  async exportToCanvas() {
    var _a;
    let nodes = (_a = this.branchAllNodes.find((b) => b.branchTab == this.plugin.settings.BranchTab)) == null ? void 0 : _a.branchNodes;
    if (typeof nodes === "undefined")
      return;
    const cardWidth = this.plugin.settings.cardWidth;
    const cardHeight = this.plugin.settings.cardHeight;
    const intervalX = cardWidth / 2;
    const intervalY = cardHeight / 8;
    const maxLength = Math.max(...nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...nodes.map((n) => n.IDArr.length));
    for (let i = maxLength - 1; i >= minLength; i--) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      for (let node of layerNodes) {
        let sons = nodes.filter((n) => n.IDStr.startsWith(node.IDStr) && n.IDArr.length == i + 1);
        if (sons.length > 0) {
          let target = nodes.indexOf(node);
          if (target >= 0) {
            nodes[target].nodeSons = sons.reduce((count, node2) => count + node2.nodeSons, 0);
          }
        } else {
          node.nodeSons = 1;
        }
      }
    }
    for (let i = minLength; i <= maxLength; i++) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      let deep = 0;
      for (let j = 0; j < layerNodes.length; j++) {
        let father = nodes.find((n) => layerNodes[j].IDStr.startsWith(n.IDStr) && n.IDArr.length === i - 1);
        if (typeof father !== "undefined") {
          layerNodes[j].startY = father.startY + deep;
          let height = intervalY * (layerNodes[j].nodeSons - 1) + cardHeight * layerNodes[j].nodeSons;
          layerNodes[j].height = father.startY + deep + height / 2;
          deep = deep + height + intervalY;
          if (j < layerNodes.length - 1) {
            let nextFather = nodes.find((n) => layerNodes[j + 1].IDStr.startsWith(n.IDStr) && n.IDArr.length === i - 1);
            if (typeof nextFather !== "undefined" && father !== nextFather) {
              deep = 0;
            }
          }
        } else {
          layerNodes[j].height = (intervalY * (layerNodes[j].nodeSons - 1) + cardHeight * layerNodes[j].nodeSons) / 2;
        }
      }
    }
    this.tightCards(nodes);
    let canvasNodeStr = "";
    let canvasEdgeStr = "";
    for (let i = 0; i < nodes.length; i++) {
      let positionX = (nodes[i].IDArr.length - nodes[0].IDArr.length) * (cardWidth + intervalX);
      let positionY = nodes[i].height;
      canvasNodeStr = canvasNodeStr + `
            {"id":"${nodes[i].randomId}","x":${positionX},"y":${positionY},"width":${cardWidth},"height":${cardHeight},"type":"file","file":"${nodes[i].file.path}"},`;
      let IDStr = nodes[i].IDStr;
      let IDArr = nodes[i].IDArr;
      let sonNodes = nodes.filter((n) => n.IDStr.startsWith(IDStr) && n.IDArr.length == IDArr.length + 1);
      for (let son of sonNodes) {
        canvasEdgeStr = canvasEdgeStr + `
                {"id":"${random(16)}","fromNode":"${nodes[i].randomId}","fromSide":"right","toNode":"${son.randomId}","toSide":"left"},`;
      }
    }
    if (canvasNodeStr.length > 0) {
      canvasNodeStr = canvasNodeStr.slice(0, -1);
    }
    if (canvasEdgeStr.length > 0) {
      canvasEdgeStr = canvasEdgeStr.slice(0, -1);
    }
    let fileContent = `{
        "nodes":[${canvasNodeStr}
        ],
        "edges":[${canvasEdgeStr}
	    ]
        }`;
    let targetfile;
    let filePath = "";
    if (this.plugin.settings.canvasFilePath.endsWith(".canvas")) {
      filePath = this.plugin.settings.canvasFilePath;
      targetfile = this.app.vault.getAbstractFileByPath(filePath);
      if (targetfile && targetfile instanceof import_obsidian8.TFile) {
        await this.app.vault.modify(targetfile, fileContent);
      }
    }
    if (!(targetfile instanceof import_obsidian8.TFile)) {
      if (filePath == "") {
        filePath = `${(0, import_obsidian8.moment)().format("YYYY-MM-DD HH.mm.ss")}.canvas`;
      }
      new import_obsidian8.Notice("create new canvas file: " + filePath);
      targetfile = await this.app.vault.create(filePath, fileContent);
    }
    if (targetfile instanceof import_obsidian8.TFile) {
      let leaf = this.app.workspace.getLeavesOfType("canvas").filter((l) => l.getDisplayText() == targetfile.basename);
      if (leaf.length > 0) {
        this.app.workspace.revealLeaf(leaf[0]);
      } else {
        this.app.workspace.openLinkText("", targetfile.path);
      }
    }
  }
  tightCards(nodes) {
    const cardHeight = this.plugin.settings.cardHeight;
    const intervalY = cardHeight / 8;
    const maxLength = Math.max(...nodes.map((n) => n.IDArr.length));
    const minLength = Math.min(...nodes.map((n) => n.IDArr.length));
    for (let i = maxLength - 1; i >= minLength; i--) {
      let layerNodes = nodes.filter((n) => n.IDArr.length === i);
      for (let node of layerNodes) {
        let sons = nodes.filter((n) => n.IDStr.startsWith(node.IDStr) && n.IDArr.length == i + 1);
        if (sons.length > 1) {
          let upSons = sons.filter((n) => n.height + cardHeight < node.height + (cardHeight + intervalY) / 2);
          for (let j = upSons.length - 1; j >= 0; j--) {
            let gapYArr = [];
            let sequentNodes = nodes.filter((n) => n.IDStr.startsWith(upSons[j].IDStr));
            let maxLen = Math.max(...sequentNodes.map((n) => n.IDArr.length));
            for (let k = upSons[j].IDArr.length; k <= maxLen; k++) {
              let temLayerNodes = sequentNodes.filter((n) => n.IDArr.length === k);
              let maxHeightNode = temLayerNodes.find((n) => n.height == Math.max(...temLayerNodes.map((n2) => n2.height)));
              if (typeof maxHeightNode !== "undefined") {
                let columnNodes = nodes.filter((n) => n.IDArr.length === k);
                let nextNodeIndex = columnNodes.indexOf(maxHeightNode) + 1;
                let nextNode = columnNodes[nextNodeIndex];
                if (typeof nextNode !== "undefined") {
                  let gapY = nextNode.height - maxHeightNode.height - cardHeight;
                  if (gapY >= intervalY) {
                    gapYArr.push(gapY);
                  }
                }
              }
            }
            if (gapYArr.length > 0) {
              if (j == upSons.length - 1) {
                let firstGapY = node.height + (cardHeight + intervalY) / 2 - upSons[upSons.length - 1].height - cardHeight;
                if (firstGapY > intervalY) {
                  gapYArr.push(firstGapY);
                } else {
                  continue;
                }
                gapYArr.push(firstGapY);
              }
              let minGapY = Math.min(...gapYArr);
              if (minGapY > intervalY) {
                for (let item of sequentNodes) {
                  nodes[nodes.indexOf(item)].height += minGapY - intervalY;
                }
              }
            }
          }
          let bottomSons = sons.filter((n) => n.height > node.height + (cardHeight + intervalY) / 2);
          for (let j = 0; j < bottomSons.length; j++) {
            let gapYArr = [];
            let sequentNodes = nodes.filter((n) => n.IDStr.startsWith(bottomSons[j].IDStr));
            let maxLen = Math.max(...sequentNodes.map((n) => n.IDArr.length));
            for (let k = bottomSons[j].IDArr.length; k <= maxLen; k++) {
              let temLayerNodes = sequentNodes.filter((n) => n.IDArr.length === k);
              let minHeightNode = temLayerNodes.find((n) => n.height == Math.min(...temLayerNodes.map((n2) => n2.height)));
              if (typeof minHeightNode !== "undefined") {
                let columnNodes = nodes.filter((n) => n.IDArr.length === k);
                let previousNodeIndex = columnNodes.indexOf(minHeightNode) - 1;
                let previousNode = columnNodes[previousNodeIndex];
                if (typeof previousNode !== "undefined") {
                  let gapY = minHeightNode.height - previousNode.height - cardHeight;
                  if (gapY >= intervalY) {
                    gapYArr.push(gapY);
                  }
                }
              }
            }
            if (gapYArr.length > 0) {
              if (j == 0) {
                let firstGapY = bottomSons[0].height - node.height - (cardHeight - intervalY) / 2;
                if (firstGapY > intervalY) {
                  gapYArr.push(firstGapY);
                } else {
                  continue;
                }
                gapYArr.push(firstGapY);
              }
              let minGapY = Math.min(...gapYArr);
              if (minGapY > intervalY) {
                for (let item of sequentNodes) {
                  nodes[nodes.indexOf(item)].height -= minGapY - intervalY;
                }
              }
            }
          }
        }
      }
    }
  }
  branchGrowing() {
    const branchMermaid = document.getElementById(`zk-index-mermaid-${this.plugin.settings.BranchTab}-svg`);
    if (branchMermaid == null)
      return;
    let nodeGArr = Array.from(branchMermaid.querySelectorAll("[id^='flowchart-']"));
    let lines = Array.from(branchMermaid.querySelectorAll(`[id^='L-']`));
    nodeGArr.forEach((item) => {
      item.setAttribute("style", "display:none");
    });
    lines.forEach((item) => {
      item.setAttribute("style", "display:none");
    });
    this.plugin.tableArr = [];
    for (let i = 0; i < nodeGArr.length; i++) {
      let nodePosStr = nodeGArr[i].id.split("-")[1];
      let node = this.plugin.MainNotes.filter((n) => n.position == Number(nodePosStr))[0];
      this.plugin.tableArr.push(node);
    }
    this.plugin.tableArr.sort((a, b) => a.ctime.localeCompare(b.ctime));
    let sec = 500;
    for (let node of this.plugin.tableArr) {
      setTimeout(() => {
        let nodeG = nodeGArr.find((n) => n.id.startsWith(`flowchart-${node.position}`));
        if (nodeG) {
          nodeG.setAttribute("style", "display:block");
        }
        let line = lines.find((n) => n.id.split("-")[2] == node.position.toString());
        if (line) {
          line.setAttribute("style", "display:block");
        }
      }, sec);
      sec = sec + 500;
    }
  }
  async onClose() {
    this.plugin.saveData(this.plugin.settings);
  }
};

// src/modal/expandGraphModal.ts
var import_obsidian9 = require("obsidian");
var expandGraphModal = class extends import_obsidian9.Modal {
  constructor(app, plugin, mainNotes, files, mermaidStr) {
    super(app);
    this.plugin = plugin;
    this.mainNotes = mainNotes;
    this.mermaidStr = mermaidStr;
    this.files = files;
  }
  async onOpen() {
    let { contentEl } = this;
    this.modalEl.addClass("zk-expand-modal");
    const mermaid = await (0, import_obsidian9.loadMermaid)();
    const svgGraph = contentEl.createEl("div", { cls: "zk-expand-graph" });
    svgGraph.id = "zk-expand-graph";
    let { svg } = await mermaid.render(`zk-expand-graph-svg`, `${this.mermaidStr}`);
    svgGraph.insertAdjacentHTML("beforeend", svg);
    svgGraph.children[0].setAttribute("width", "100%");
    svgGraph.children[0].setAttribute("height", `${this.contentEl.offsetHeight - 5}px`);
    this.contentEl.appendChild(svgGraph);
    const svgPanZoom = require_browserify();
    let panZoomTiger = svgPanZoom(`#zk-expand-graph-svg`, {
      zoomEnabled: true,
      controlIconsEnabled: false,
      fit: false,
      center: true,
      minZoom: 1e-3,
      maxZoom: 1e3,
      dblClickZoomEnabled: false,
      zoomScaleSensitivity: 0.25
    });
    let setSvg = document.getElementById(`${svgGraph.id}-svg`);
    if (setSvg !== null) {
      let a = setSvg.children[0].getAttr("style");
      if (typeof a == "string") {
        let b = a.match(/\d([^\,]+)\d/g);
        if (b !== null && Number(b[0]) > 1) {
          panZoomTiger.zoom(1 / Number(b[0]));
        }
      }
    }
    let nodeGArr = svgGraph.querySelectorAll("[id^='flowchart-']");
    let nodeArr = svgGraph.getElementsByClassName("nodeLabel");
    for (let i = 0; i < nodeArr.length; i++) {
      let link = document.createElement("a");
      link.addClass("internal-link");
      let nodePosStr = nodeGArr[i].id.split("-")[1];
      let path = "";
      if (this.files.length == 0) {
        path = this.mainNotes.filter((n) => n.position == Number(nodePosStr))[0].file.path;
      } else {
        path = this.files[Number(nodePosStr)].path;
      }
      link.textContent = nodeArr[i].getText();
      nodeArr[i].textContent = "";
      nodeArr[i].appendChild(link);
      nodeGArr[i].addEventListener("click", (event) => {
        if (event.ctrlKey) {
          this.app.workspace.openLinkText("", path, "tab");
        } else if (event.shiftKey) {
          this.plugin.FileforLocaLgraph = path;
          this.plugin.openGraphView();
        } else if (event.altKey) {
          let mainNote = this.plugin.MainNotes.find((n) => n.file.path == path);
          if (mainNote) {
            this.plugin.clearShowingSettings();
            this.plugin.settings.SelectMainNote = mainNote.file.path;
            this.app.workspace.trigger("zk-navigation:refresh-index-graph");
          }
        } else {
          this.app.workspace.openLinkText("", path);
        }
      });
      nodeArr[i].addEventListener(`mouseover`, (event) => {
        this.app.workspace.trigger(`hover-link`, {
          event,
          source: ZK_NAVIGATION,
          hoverParent: this,
          linktext: "",
          targetEl: link,
          sourcePath: path
        });
      });
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};

// src/view/graphView.ts
var ZK_GRAPH_TYPE = "zk-graph-type";
var ZK_GRAPH_VIEW = t("zk-local-graph");
var ZKGraphView = class extends import_obsidian10.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshLocalGraph = async () => {
      let { containerEl } = this;
      containerEl.empty();
      const graphMermaidDiv = containerEl.createDiv().createDiv("zk-graph-mermaid-container");
      if (this.plugin.FileforLocaLgraph !== "") {
        this.currentFile = this.app.vault.getFileByPath(this.plugin.FileforLocaLgraph);
      } else {
        this.currentFile = this.app.workspace.getActiveFile();
      }
      this.plugin.FileforLocaLgraph = "";
      graphMermaidDiv.empty();
      if (this.currentFile !== null) {
        const mermaid = await (0, import_obsidian10.loadMermaid)();
        const svgPanZoom = require_browserify();
        if (this.plugin.settings.FamilyGraphToggle == true) {
          let familyNodeArr = await this.getFamilyNodes(this.currentFile);
          let familyMermaidStr = await this.genericFamilyMermaidStr(this.currentFile, familyNodeArr, this.plugin.settings.DirectionOfFamilyGraph);
          const familyGraphContainer = graphMermaidDiv.createDiv("zk-family-graph-container");
          const familyGraphTextDiv = familyGraphContainer.createDiv("zk-graph-text");
          familyGraphTextDiv.empty();
          familyGraphTextDiv.createEl("span", { text: t("close relative") });
          let graphIconDiv = familyGraphContainer.createDiv("zk-graph-icon");
          graphIconDiv.empty();
          let expandBtn = new import_obsidian10.ExtraButtonComponent(graphIconDiv);
          expandBtn.setIcon("expand").setTooltip(t("expand graph"));
          expandBtn.onClick(() => {
            new expandGraphModal(this.app, this.plugin, familyNodeArr, [], familyMermaidStr).open();
          });
          const familyTreeDiv = familyGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
          familyTreeDiv.id = "zk-family-tree";
          let { svg } = await mermaid.render(`${familyTreeDiv.id}-svg`, `${familyMermaidStr}`);
          familyTreeDiv.insertAdjacentHTML("beforeend", svg);
          familyTreeDiv.children[0].setAttribute("width", "100%");
          familyTreeDiv.children[0].setAttribute("height", `${this.plugin.settings.HeightOfFamilyGraph}px`);
          graphMermaidDiv.appendChild(familyTreeDiv);
          let panZoomTiger = svgPanZoom(`#${familyTreeDiv.id}-svg`, {
            zoomEnabled: true,
            controlIconsEnabled: false,
            fit: false,
            center: true,
            minZoom: 1e-3,
            maxZoom: 1e3,
            dblClickZoomEnabled: false,
            zoomScaleSensitivity: 0.3
          });
          let setSvg = document.getElementById(`${familyTreeDiv.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (typeof a == "string") {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
          }
          let nodeGArr = familyTreeDiv.querySelectorAll("[id^='flowchart-']");
          let nodeArr = familyTreeDiv.getElementsByClassName("nodeLabel");
          for (let i = 0; i < nodeArr.length; i++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i].id.split("-")[1];
            let node = familyNodeArr.filter((n) => n.position == Number(nodePosStr))[0];
            link.textContent = nodeArr[i].getText();
            nodeArr[i].textContent = "";
            nodeArr[i].appendChild(link);
            nodeGArr[i].addEventListener("click", (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.file.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.FileforLocaLgraph = node.file.path;
                this.plugin.openGraphView();
              } else if (event.altKey) {
                this.plugin.clearShowingSettings();
                this.plugin.settings.SelectMainNote = node.file.path;
                this.plugin.RefreshIndexViewFlag = true;
                this.plugin.openIndexView();
              } else {
                this.app.workspace.openLinkText("", node.file.path);
              }
            });
            nodeGArr[i].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: "",
                targetEl: link,
                sourcePath: node.file.path
              });
            });
          }
        }
        if (this.plugin.settings.InlinksGraphToggle == true) {
          let inlinkArr = await this.getInlinks(this.currentFile);
          let inlinkMermaidStr = await this.genericLinksMermaidStr(this.currentFile, inlinkArr, "in", this.plugin.settings.DirectionOfInlinksGraph);
          const inlinksGraphContainer = graphMermaidDiv.createDiv("zk-inlinks-graph-container");
          const inlinksGraphTextDiv = inlinksGraphContainer.createDiv("zk-graph-text");
          inlinksGraphTextDiv.empty();
          inlinksGraphTextDiv.createEl("span", { text: t("inlinks") });
          let graphIconDiv = inlinksGraphContainer.createDiv("zk-graph-icon");
          graphIconDiv.empty();
          let expandBtn = new import_obsidian10.ExtraButtonComponent(graphIconDiv);
          expandBtn.setIcon("expand").setTooltip(t("expand graph"));
          expandBtn.onClick(() => {
            new expandGraphModal(this.app, this.plugin, [], inlinkArr, inlinkMermaidStr).open();
          });
          const inlinksDiv = inlinksGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
          inlinksDiv.id = "zk-inlinks";
          let { svg } = await mermaid.render(`${inlinksDiv.id}-svg`, inlinkMermaidStr);
          inlinksDiv.insertAdjacentHTML("beforeend", svg);
          inlinksDiv.children[0].setAttribute("width", "100%");
          inlinksDiv.children[0].setAttribute("height", `${this.plugin.settings.HeightOfInlinksGraph}px`);
          graphMermaidDiv.appendChild(inlinksDiv);
          let panZoomTiger = svgPanZoom(`#${inlinksDiv.id}-svg`, {
            zoomEnabled: true,
            controlIconsEnabled: false,
            fit: false,
            center: true,
            minZoom: 1e-3,
            maxZoom: 1e3,
            dblClickZoomEnabled: false,
            zoomScaleSensitivity: 0.3
          });
          let setSvg = document.getElementById(`${inlinksDiv.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (typeof a == "string") {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
          }
          let nodeGArr = inlinksDiv.querySelectorAll("[id^='flowchart-']");
          let nodeArr = inlinksDiv.getElementsByClassName("nodeLabel");
          inlinkArr.push(this.currentFile);
          for (let i = 0; i < nodeArr.length; i++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i].id.split("-")[1];
            let node = inlinkArr[Number(nodePosStr)];
            link.textContent = nodeArr[i].getText();
            nodeArr[i].textContent = "";
            nodeArr[i].appendChild(link);
            nodeGArr[i].addEventListener("click", (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.FileforLocaLgraph = node.path;
                this.plugin.openGraphView();
              } else if (event.altKey) {
                let mainNote = this.plugin.MainNotes.find((n) => n.file.path == node.path);
                if (mainNote) {
                  this.plugin.clearShowingSettings();
                  this.plugin.settings.SelectMainNote = mainNote.file.path;
                  this.plugin.RefreshIndexViewFlag = true;
                  this.plugin.openIndexView();
                }
              } else {
                this.app.workspace.openLinkText("", node.path);
              }
            });
            nodeGArr[i].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: "",
                targetEl: link,
                sourcePath: node.path
              });
            });
          }
        }
        if (this.plugin.settings.OutlinksGraphToggle == true) {
          let outlinkArr = [];
          if (this.currentFile.extension === "md") {
            outlinkArr = await this.getOutlinks(this.currentFile);
          }
          let outlinkMermaidStr = await this.genericLinksMermaidStr(this.currentFile, outlinkArr, "out", this.plugin.settings.DirectionOfOutlinksGraph);
          const outlinksGraphContainer = graphMermaidDiv.createDiv("zk-outlinks-graph-container");
          const outlinksGraphTextDiv = outlinksGraphContainer.createDiv("zk-graph-text");
          outlinksGraphTextDiv.empty();
          outlinksGraphTextDiv.createEl("span", { text: t("outlinks") });
          let graphIconDiv = outlinksGraphContainer.createDiv("zk-graph-icon");
          graphIconDiv.empty();
          let expandBtn = new import_obsidian10.ExtraButtonComponent(graphIconDiv);
          expandBtn.setIcon("expand").setTooltip(t("expand graph"));
          expandBtn.onClick(() => {
            new expandGraphModal(this.app, this.plugin, [], outlinkArr, outlinkMermaidStr).open();
          });
          const outlinksDiv = outlinksGraphContainer.createEl("div", { cls: "zk-graph-mermaid" });
          outlinksDiv.id = "zk-outlinks";
          let { svg } = await mermaid.render(`${outlinksDiv.id}-svg`, outlinkMermaidStr);
          outlinksDiv.insertAdjacentHTML("beforeend", svg);
          outlinksDiv.children[0].setAttribute("width", "100%");
          outlinksDiv.children[0].setAttribute("height", `${this.plugin.settings.HeightOfOutlinksGraph}px`);
          graphMermaidDiv.appendChild(outlinksDiv);
          let panZoomTiger = svgPanZoom(`#${outlinksDiv.id}-svg`, {
            zoomEnabled: true,
            controlIconsEnabled: false,
            fit: false,
            center: true,
            minZoom: 1e-3,
            maxZoom: 1e3,
            dblClickZoomEnabled: false,
            zoomScaleSensitivity: 0.3
          });
          let setSvg = document.getElementById(`${outlinksDiv.id}-svg`);
          if (setSvg !== null) {
            let a = setSvg.children[0].getAttr("style");
            if (typeof a == "string") {
              let b = a.match(/\d([^\,]+)\d/g);
              if (b !== null && Number(b[0]) > 1) {
                panZoomTiger.zoom(1 / Number(b[0]));
              }
            }
          }
          let nodeGArr = outlinksDiv.querySelectorAll("[id^='flowchart-']");
          let nodeArr = outlinksDiv.getElementsByClassName("nodeLabel");
          outlinkArr.push(this.currentFile);
          for (let i = 0; i < nodeArr.length; i++) {
            let link = document.createElement("a");
            link.addClass("internal-link");
            let nodePosStr = nodeGArr[i].id.split("-")[1];
            let node = outlinkArr[Number(nodePosStr)];
            link.textContent = nodeArr[i].getText();
            nodeArr[i].textContent = "";
            nodeArr[i].appendChild(link);
            nodeGArr[i].addEventListener("click", async (event) => {
              if (event.ctrlKey) {
                this.app.workspace.openLinkText("", node.path, "tab");
              } else if (event.shiftKey) {
                this.plugin.FileforLocaLgraph = node.path;
                this.plugin.openGraphView();
              } else if (event.altKey) {
                let mainNote = this.plugin.MainNotes.find((n) => n.file.path == node.path);
                if (mainNote) {
                  this.plugin.clearShowingSettings();
                  this.plugin.settings.SelectMainNote = mainNote.file.path;
                  this.plugin.RefreshIndexViewFlag = true;
                  this.plugin.openIndexView();
                }
              } else {
                this.app.workspace.openLinkText("", node.path);
              }
            });
            nodeGArr[i].addEventListener(`mouseover`, (event) => {
              this.app.workspace.trigger(`hover-link`, {
                event,
                source: ZK_NAVIGATION,
                hoverParent: this,
                linktext: "",
                targetEl: link,
                sourcePath: node.path
              });
            });
          }
        }
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_GRAPH_TYPE;
  }
  getDisplayText() {
    return ZK_GRAPH_VIEW;
  }
  getIcon() {
    return "network";
  }
  async onOpen() {
    this.refreshLocalGraph();
  }
  onload() {
    const refresh = (0, import_obsidian10.debounce)(this.refreshLocalGraph, 300, true);
    this.registerEvent(this.app.vault.on("rename", () => {
      refresh();
    }));
    this.registerEvent(this.app.vault.on("create", () => {
      refresh();
    }));
    this.registerEvent(this.app.vault.on("delete", () => {
      refresh();
    }));
    this.registerEvent(this.app.metadataCache.on("changed", () => {
      refresh();
    }));
    this.registerEvent(this.app.metadataCache.on("deleted", () => {
      refresh();
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", async (leaf) => {
      if (this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE).length > 0) {
        if (this.app.workspace.getActiveViewOfType(import_obsidian10.FileView)) {
          refresh();
        }
      }
    }));
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-local-graph", refresh));
  }
  async getFamilyNodes(currentFile) {
    let familyNodeArr = [];
    await mainNoteInit(this.plugin);
    let currentNode = this.plugin.MainNotes.filter((n) => n.file == currentFile)[0];
    if (typeof currentNode !== "undefined") {
      if (currentNode.IDArr.length > 1) {
        let fatherArr = currentNode.IDArr.slice(0, currentNode.IDArr.length - 1);
        let fatherNode = this.plugin.MainNotes.filter((n) => n.IDStr == fatherArr.toString());
        if (fatherNode.length > 0) {
          familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(fatherNode[0].IDStr)).filter((n) => n.IDArr.length <= currentNode.IDArr.length || n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length == currentNode.IDArr.length + 1);
        } else {
          familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length <= currentNode.IDArr.length + 1);
        }
      } else {
        familyNodeArr = this.plugin.MainNotes.filter((n) => n.IDStr.startsWith(currentNode.IDStr) && n.IDArr.length <= currentNode.IDArr.length + 1);
      }
    }
    return familyNodeArr;
  }
  async getInlinks(currentFile) {
    let inlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    for (let src of Object.keys(resolvedLinks)) {
      let link = resolvedLinks[src];
      for (let dest of Object.keys(link)) {
        if (dest === currentFile.path) {
          let inlinkFile = this.app.vault.getFileByPath(src);
          if (inlinkFile !== null) {
            inlinkArr.push(inlinkFile);
          }
        }
      }
    }
    return inlinkArr;
  }
  async getOutlinks(currentFile) {
    let outlinkArr = [];
    const resolvedLinks = this.app.metadataCache.resolvedLinks;
    let outlinks = Object.keys(resolvedLinks[currentFile.path]);
    if (this.plugin.settings.FileExtension == "md") {
      outlinks = outlinks.filter((link) => link.endsWith(".md"));
    }
    for (let outlink of outlinks) {
      let outlinkFile = this.app.vault.getFileByPath(outlink);
      if (outlinkFile !== null) {
        outlinkArr.push(outlinkFile);
      }
    }
    return outlinkArr;
  }
  async genericLinksMermaidStr(currentFile, linkArr, direction1 = "in", direction2) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'basis' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction2};
`;
    let currentNode = [];
    if (this.plugin.MainNotes.length > 0) {
      currentNode = this.plugin.MainNotes.filter((n) => n.file === currentFile);
    }
    if (currentNode.length > 0) {
      mermaidStr = mermaidStr + `${linkArr.length}("${currentNode[0].displayText}");
            style ${linkArr.length} fill:#ffa,stroke:#333,stroke-width:1px 
`;
      ;
    } else {
      mermaidStr = mermaidStr + `${linkArr.length}("${currentFile.basename}");
            style ${linkArr.length} fill:#ffa,stroke:#333,stroke-width:1px 
`;
      ;
    }
    for (let i = 0; i < linkArr.length; i++) {
      let node = this.plugin.MainNotes.find((n) => n.file == linkArr[i]);
      if (typeof node !== "undefined") {
        mermaidStr = mermaidStr + `${i}("${node.displayText}");
`;
      } else {
        mermaidStr = mermaidStr + `${i}("${linkArr[i].basename}");
`;
      }
      mermaidStr = mermaidStr + `style ${i} fill:#fff; 
`;
      if (direction1 == "in") {
        mermaidStr = mermaidStr + `${i} --> ${linkArr.length};
`;
      } else {
        mermaidStr = mermaidStr + `${linkArr.length} --> ${i};
`;
      }
    }
    return mermaidStr;
  }
  async genericFamilyMermaidStr(currentFile, Nodes, direction) {
    let mermaidStr = `%%{ init: { 'flowchart': { 'curve': 'basis' },
        'themeVariables':{ 'fontSize': '12px'}}}%% flowchart ${direction};`;
    for (let node of Nodes) {
      mermaidStr = mermaidStr + `${node.position}("${node.displayText}");
`;
      if (node.file == currentFile) {
        mermaidStr = mermaidStr + `style ${node.position} fill:#ffa,stroke:#333,stroke-width:1px 
`;
      } else {
        mermaidStr = mermaidStr + `style ${node.position} fill:#fff; 
`;
      }
    }
    for (let node of Nodes) {
      let sonNodes = Nodes.filter((n) => n.IDArr.length - 1 == node.IDArr.length && n.IDStr.startsWith(node.IDStr) && n.ID.startsWith(node.ID));
      for (let son of sonNodes) {
        mermaidStr = mermaidStr + `${node.position} --> ${son.position};
`;
      }
    }
    if (this.plugin.settings.RedDashLine === true) {
      for (let node of Nodes) {
        if (/^[a-zA-Z]$/.test(node.file.basename.slice(-1))) {
          mermaidStr = mermaidStr + `style ${node.position} stroke:#f66,stroke-width:2px,stroke-dasharray: 1 
`;
        }
      }
    }
    return mermaidStr;
  }
  async onClose() {
  }
};

// src/view/outlineView.ts
var import_obsidian11 = require("obsidian");
var ZK_OUTLINE_TYPE = "zk-outline-type";
var ZK_OUTLINE_VIEW = t("list tree");
var ZKOutlineView = class extends import_obsidian11.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshOutlineView = async () => {
      let { containerEl } = this;
      containerEl.empty();
      const headerDiv = containerEl.createDiv("nav-header").createDiv("nav-buttons-container");
      this.maxLength = Math.max(...this.plugin.tableArr.map((n) => n.IDArr.length));
      this.minLength = Math.min(...this.plugin.tableArr.map((n) => n.IDArr.length));
      this.defautLength = this.plugin.settings.outlineLayer;
      const slider = new import_obsidian11.SliderComponent(headerDiv);
      let maxLayer = this.maxLength - this.minLength + 1;
      if (this.defautLength > maxLayer) {
        this.defautLength = maxLayer;
      }
      slider.setLimits(1, maxLayer, 1).setDynamicTooltip().setValue(this.defautLength).onChange((value) => {
        this.plugin.settings.outlineLayer = value;
        this.plugin.saveData(this.plugin.settings);
        this.app.workspace.trigger("zk-navigation:refresh-outline-view");
      });
      const outlineViewDiv = this.containerEl.createDiv("view-content node-insert-event");
      outlineViewDiv.id = "view-content";
      await this.createListTree(this.plugin.tableArr[0], outlineViewDiv);
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_OUTLINE_TYPE;
  }
  getDisplayText() {
    return ZK_OUTLINE_VIEW;
  }
  getIcon() {
    return "list-tree";
  }
  onload() {
    const refresh = (0, import_obsidian11.debounce)(this.refreshOutlineView, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-outline-view", refresh));
  }
  async onOpen() {
    this.refreshOutlineView();
  }
  async createListTree(item, itemEl) {
    let children = this.plugin.tableArr.filter((n) => n.IDArr.length === item.IDArr.length + 1 && n.IDStr.startsWith(item.IDStr));
    let treeItem = itemEl.createDiv("tree-item");
    let treeItemSelf = treeItem.createDiv("tree-item-self is-clickable");
    treeItemSelf.addEventListener(`mouseover`, (event) => {
      this.app.workspace.trigger(`hover-link`, {
        event,
        source: ZK_NAVIGATION,
        hoverParent: this,
        linktext: "",
        targetEl: treeItemSelf,
        sourcePath: item.file.path
      });
    });
    treeItemSelf.addEventListener("click", async (event) => {
      if (event.ctrlKey) {
        navigator.clipboard.writeText(item.ID);
        new import_obsidian11.Notice(item.ID + " copied");
      } else if (event.shiftKey) {
        this.plugin.settings.SelectIndex = "";
        this.plugin.settings.SelectMainNote = item.file.path;
        await this.plugin.clearShowingSettings();
        this.plugin.RefreshIndexViewFlag = true;
        this.plugin.openIndexView();
      } else if (event.altKey) {
        this.plugin.FileforLocaLgraph = item.file.path;
        this.plugin.openGraphView();
      } else {
        this.app.workspace.openLinkText("", item.file.path);
      }
    });
    const treeItemChildren = treeItem.createDiv("tree-item-children");
    let treeIteminner = treeItemSelf.createDiv("tree-item-inner");
    treeIteminner.setText(`${item.displayText}`);
    if (children.length > 0) {
      let treeItemIcon = treeItemSelf.createDiv("tree-item-icon collapse-icon");
      let icon = new import_obsidian11.ExtraButtonComponent(treeItemIcon);
      icon.setIcon("right-triangle");
      treeItemIcon.addEventListener("click", (event) => {
        if (treeItemIcon.hasClass("is-collapsed")) {
          treeItemIcon.removeClass("is-collapsed");
          treeItemChildren.setAttr("style", "display:block");
        } else {
          treeItemIcon.addClass("is-collapsed");
          treeItemChildren.setAttr("style", "display:none");
        }
        event.stopPropagation();
      });
      if (item.IDArr.length - this.minLength + 1 >= this.defautLength) {
        treeItemIcon.addClass("is-collapsed");
        treeItemChildren.setAttr("style", "display:none");
      }
      for (let i = 0; i < children.length; i++) {
        await this.createListTree(children[i], treeItemChildren);
      }
    }
  }
};

// src/view/recentView.ts
var import_obsidian12 = require("obsidian");
var ZK_RECENT_TYPE = "zk-recent-type";
var ZK_RECENT_VIEW = t("History List");
var ZKRecentView = class extends import_obsidian12.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.refreshRecentView = async () => {
      let { containerEl } = this;
      containerEl.empty();
      const historyListDiv = this.containerEl.createDiv("view-content node-insert-event");
      for (let i = 0; i < this.plugin.settings.HistoryList.length; i++) {
        let item = this.plugin.settings.HistoryList[i];
        let line = historyListDiv.createEl("div", { text: `${i + 1}. ${item.displayText}`, cls: "vertical-tab-nav-item recent-item" });
        line.addEventListener(`mousemove`, (event) => {
          this.app.workspace.trigger(`hover-link`, {
            event,
            source: ZK_NAVIGATION,
            hoverParent: line,
            linktext: "",
            targetEl: line,
            sourcePath: item.filePath
          });
        });
        line.addEventListener("click", async () => {
          if (this.plugin.settings.FolderOfIndexes !== "" && item.filePath.startsWith(this.plugin.settings.FolderOfIndexes)) {
            this.plugin.settings.SelectIndex = item.filePath;
            this.plugin.settings.SelectMainNote = "";
          } else {
            this.plugin.settings.SelectMainNote = item.filePath;
            this.plugin.settings.SelectIndex = "";
          }
          let history = {
            displayText: item.displayText,
            filePath: item.filePath,
            openTime: (0, import_obsidian12.moment)().format("YYYY-MM-DD HH:mm:ss")
          };
          this.plugin.settings.HistoryList.splice(i, 1);
          this.plugin.settings.HistoryList.unshift(history);
          this.plugin.settings.zoomPanScaleArr = [];
          this.plugin.settings.BranchTab = 0;
          this.plugin.settings.FoldNodeArr = [];
          this.app.workspace.trigger("zk-navigation:refresh-recent-view");
          this.plugin.RefreshIndexViewFlag = true;
          this.plugin.openIndexView();
        });
        const closeBtnDiv = line.createDiv("recent-close-button");
        const closeBtn = new import_obsidian12.ExtraButtonComponent(closeBtnDiv);
        closeBtn.setIcon("x");
        closeBtnDiv.addEventListener("click", (event) => {
          this.plugin.settings.HistoryList.splice(i, 1);
          this.app.workspace.trigger("zk-navigation:refresh-recent-view");
          event.stopPropagation();
        });
        line.addEventListener("mouseenter", function() {
          closeBtnDiv.setAttr("style", "display:block");
        });
        line.addEventListener("mouseleave", function() {
          closeBtnDiv.setAttr("style", "display:none");
        });
      }
    };
    this.plugin = plugin;
  }
  getViewType() {
    return ZK_RECENT_TYPE;
  }
  getDisplayText() {
    return ZK_RECENT_VIEW;
  }
  getIcon() {
    return "history";
  }
  onload() {
    const refresh = (0, import_obsidian12.debounce)(this.refreshRecentView, 300, true);
    this.registerEvent(this.app.workspace.on("zk-navigation:refresh-recent-view", refresh));
  }
  async onOpen() {
    this.refreshRecentView();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  FolderOfMainNotes: "",
  FolderOfIndexes: "",
  SelectIndex: "",
  StartingPoint: "father",
  DisplayLevel: "end",
  NodeText: "both",
  FamilyGraphToggle: true,
  InlinksGraphToggle: true,
  OutlinksGraphToggle: true,
  TagOfMainNotes: "",
  IDFieldOption: "1",
  TitleField: "",
  IDField: "",
  Separator: " ",
  IndexButtonText: t("\u{1F4D6}index"),
  SuggestMode: "fuzzySuggest",
  FoldToggle: false,
  FoldNodeArr: [],
  RedDashLine: false,
  zoomPanScaleArr: [],
  CustomCreatedTime: "",
  BranchTab: 0,
  FileExtension: "md",
  SectionTab: 0,
  HeightOfFamilyGraph: 200,
  HeightOfInlinksGraph: 200,
  HeightOfOutlinksGraph: 200,
  DirectionOfBranchGraph: "LR",
  DirectionOfFamilyGraph: "LR",
  DirectionOfInlinksGraph: "TB",
  DirectionOfOutlinksGraph: "TB",
  BranchToolbra: true,
  RandomIndex: true,
  RandomMainNote: true,
  TableView: true,
  IndexButton: true,
  MainNoteButton: true,
  MainNoteButtonText: t("Main notes"),
  SelectMainNote: "",
  settingIcon: true,
  MainNoteSuggestMode: "fuzzySuggest",
  ListTree: true,
  HistoryList: [],
  HistoryToggle: true,
  HistoryMaxCount: 20,
  exportCanvas: true,
  cardWidth: 400,
  cardHeight: 240,
  canvasFilePath: "",
  siblingsOrder: "number",
  showAll: false,
  showAllToggle: true,
  play: true,
  outlineLayer: 2
};
var ZKNavigationPlugin = class extends import_obsidian13.Plugin {
  constructor() {
    super(...arguments);
    this.FileforLocaLgraph = "";
    this.indexViewOffsetWidth = 0;
    this.indexViewOffsetHeight = 0;
    this.RefreshIndexViewFlag = false;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async onload() {
    await this.loadSettings();
    this.registerObsidianProtocolHandler("zk-navigation", async (para) => {
      if (para.file) {
        let file = this.app.vault.getFileByPath(para.file);
        if (!file) {
          new import_obsidian13.Notice(`zk-navigation: file "${para.file}" can't be found!`);
          return;
        }
        if (para.from && ["root", "father", "branch"].includes(para.from)) {
          this.settings.StartingPoint = para.from;
        }
        if (para.to && ["next", "end"].includes(para.to)) {
          this.settings.DisplayLevel = para.to;
        }
        if (para.text && ["id", "title", "both"].includes(para.text)) {
          this.settings.NodeText = para.text;
        }
        let indexFlag = false;
        if (this.settings.FolderOfIndexes !== "") {
          if (para.file.startsWith(this.settings.FolderOfIndexes)) {
            indexFlag = true;
            this.settings.SelectIndex = para.file;
            this.settings.SelectMainNote = "";
            this.settings.zoomPanScaleArr = [];
            this.settings.BranchTab = 0;
            this.settings.FoldNodeArr = [];
            this.RefreshIndexViewFlag = true;
            await this.openIndexView();
          }
        }
        if (!indexFlag) {
          this.settings.SelectMainNote = para.file;
          this.settings.SelectIndex = "";
          this.settings.zoomPanScaleArr = [];
          this.settings.BranchTab = 0;
          this.settings.FoldNodeArr = [];
          this.RefreshIndexViewFlag = true;
          await this.openIndexView();
        }
      } else {
        new import_obsidian13.Notice(`zk-navigation: invalid uri`);
      }
    });
    this.registerEvent(this.app.workspace.on("file-menu", (menu, file, source) => {
      if (!(source === "more-options" || source === "tab-header" || source == "file-explorer-context-menu")) {
        return;
      }
      if (!(file instanceof import_obsidian13.TFile)) {
        return;
      }
      menu.addItem((item) => {
        item.setTitle(t("Copy zk-navigation URI")).setIcon("copy").setSection("info").onClick(() => navigator.clipboard.writeText(`obsidian://zk-navigation?file=${encodeURI(file.path)}`));
      });
    }));
    this.addSettingTab(new ZKNavigationSettngTab(this.app, this));
    this.registerView(ZK_INDEX_TYPE, (leaf) => new ZKIndexView(leaf, this));
    this.registerView(ZK_GRAPH_TYPE, (leaf) => new ZKGraphView(leaf, this));
    this.registerView(ZK_OUTLINE_TYPE, (leaf) => new ZKOutlineView(leaf, this));
    this.registerView(ZK_RECENT_TYPE, (leaf) => new ZKRecentView(leaf, this));
    this.addRibbonIcon("ghost", t("open zk-index-graph"), async () => {
      this.openIndexView();
    });
    this.addRibbonIcon("network", t("open zk-local-graph"), async () => {
      this.openGraphView();
    });
    this.addCommand({
      id: "zk-index-graph",
      name: t("open zk-index-graph"),
      callback: async () => {
        this.openIndexView();
      }
    });
    this.addCommand({
      id: "zk-local-graph",
      name: t("open zk-local-graph"),
      callback: async () => {
        this.openGraphView();
      }
    });
    this.addCommand({
      id: "zk-index-graph-by-file",
      name: t("reveal current file in zk-index-graph"),
      callback: async () => {
        await this.revealFileInIndexView();
      }
    });
    this.registerHoverLinkSource(ZK_NAVIGATION, {
      defaultMod: true,
      display: ZK_NAVIGATION
    });
  }
  async openIndexView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_INDEX_TYPE).length === 0) {
      await ((_a = this.app.workspace.getLeaf("tab")) == null ? void 0 : _a.setViewState({
        type: ZK_INDEX_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_INDEX_TYPE)[0]);
    if (this.RefreshIndexViewFlag === true) {
      this.app.workspace.trigger("zk-navigation:refresh-index-graph");
    }
  }
  async openGraphView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_GRAPH_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_GRAPH_TYPE)[0]);
    this.app.workspace.trigger("zk-navigation:refresh-local-graph");
  }
  async openOutlineView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_OUTLINE_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_OUTLINE_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_OUTLINE_TYPE)[0]);
    this.app.workspace.trigger("zk-navigation:refresh-outline-view");
  }
  async openRecentView() {
    var _a;
    if (this.app.workspace.getLeavesOfType(ZK_RECENT_TYPE).length === 0) {
      await ((_a = this.app.workspace.getRightLeaf(false)) == null ? void 0 : _a.setViewState({
        type: ZK_RECENT_TYPE,
        active: true
      }));
    }
    this.app.workspace.revealLeaf(this.app.workspace.getLeavesOfType(ZK_RECENT_TYPE)[0]);
    this.app.workspace.trigger("zk-navigation:refresh-recent-view");
  }
  async clearShowingSettings(BranchTab = 0) {
    this.settings.zoomPanScaleArr = [];
    this.settings.BranchTab = BranchTab;
    this.settings.FoldNodeArr = [];
  }
  async revealFileInIndexView() {
    var _a, _b;
    let filePath = (_b = (_a = this.app.workspace.getActiveViewOfType(import_obsidian13.FileView)) == null ? void 0 : _a.file) == null ? void 0 : _b.path;
    if (filePath && filePath.endsWith(".md")) {
      let indexFlag = false;
      if (this.settings.FolderOfIndexes !== "") {
        if (filePath.startsWith(this.settings.FolderOfIndexes)) {
          indexFlag = true;
          this.settings.SelectIndex = filePath;
          this.settings.SelectMainNote = "";
          this.clearShowingSettings();
          this.RefreshIndexViewFlag = true;
          await this.openIndexView();
        }
      }
      if (!indexFlag) {
        this.settings.SelectMainNote = filePath;
        this.settings.SelectIndex = "";
        this.clearShowingSettings();
        this.RefreshIndexViewFlag = true;
        await this.openIndexView();
      }
      return;
    }
  }
  onunload() {
    this.saveData(this.settings);
  }
};
